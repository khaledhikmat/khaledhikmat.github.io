(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{117:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var o=n(3),a=n(7),r=(n(0),n(138)),i={title:".NET Core, Docker and Kubernetes",author:"Khaled Hikmat",author_title:"Software Engineer",author_url:"https://github.com/khaledhikmat",author_image_url:"https://avatars1.githubusercontent.com/u/3119726?s=400&u=090899e7b366dd702f9d0d5e483f20089010b25c&v=4",tags:[".NET Core","Docker","Kubernetes"]},s={permalink:"/blog/2018/01/04/netapp-docker-k8s",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/blog/blog/2018-01-04-netapp-docker-k8s.md",source:"@site/blog/2018-01-04-netapp-docker-k8s.md",description:"I wanted to assess Azure Cosmos DB to see possibilities of converting some of our backend applications to use this database technology to provide a globally distributed database that we desperately need as our services now cover a bigger geographic location. However, this post is not about Cosmos DB specifically! It is mainly about notes about the architecture of the pieces that surround Cosmos and how I am thinking to implement them.",date:"2018-01-04T00:00:00.000Z",tags:[{label:".NET Core",permalink:"/blog/tags/net-core"},{label:"Docker",permalink:"/blog/tags/docker"},{label:"Kubernetes",permalink:"/blog/tags/kubernetes"}],title:".NET Core, Docker and Kubernetes",readingTime:7.045,truncated:!1,prevItem:{title:"Kubernetes vs. Service Fabric",permalink:"/blog/2018/01/06/kubernetes-vs-service-fabric"},nextItem:{title:"Azure CLI Notes",permalink:"/blog/2018/01/02/azure-cli-login-options"}},l=[{value:"Macro Architecture",id:"macro-architecture",children:[]},{value:"Azure App Service, Docker &amp; Kubernetes",id:"azure-app-service-docker--kubernetes",children:[]},{value:"Containerizing the WebJobs Console App",id:"containerizing-the-webjobs-console-app",children:[]},{value:"Containerizing the Change Feeder App",id:"containerizing-the-change-feeder-app",children:[]},{value:"Kubernetes",id:"kubernetes",children:[{value:"Deployments",id:"deployments",children:[]},{value:"Observations",id:"observations",children:[]}]},{value:"Application Insights",id:"application-insights",children:[]},{value:"Scaling",id:"scaling",children:[]}],c={toc:l};function p(e){var t=e.components,i=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},c,i,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"I wanted to assess Azure Cosmos DB to see possibilities of converting some of our backend applications to use this database technology to provide a globally distributed database that we desperately need as our services now cover a bigger geographic location. However, this post is not about Cosmos DB specifically! It is mainly about notes about the architecture of the pieces that surround Cosmos and how I am thinking to implement them."),Object(r.b)("h2",{id:"macro-architecture"},"Macro Architecture"),Object(r.b)("p",null,"This is how I imagines our system to look like:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Avalon Macro Architecture",src:n(166).default})),Object(r.b)("p",null,"In this post, I would like to concentrate only on the components that are boxed in orange. Namely, the Web API layer and the two processors."),Object(r.b)("h2",{id:"azure-app-service-docker--kubernetes"},"Azure App Service, Docker & Kubernetes"),Object(r.b)("p",null,"We have been using Azure App Service for a while and we are happy with it. We have experience in managing it, scaling it and configuring it. I did not want to change that. So I decided to continue to use Azure App Service to host our Web API layer which will be written in .NET Core. This layer communicates with Cosmos DB to provide a multi-regional access to our customers. "),Object(r.b)("p",null,"I wanted to monitor Cosmos DB changes to launch different Microservices in the form of Azure Functions, Logic Apps or other processes. I could use Azure Functions to track the Cosmos DB changes but I decided to write my own little .NET Core stand-alone Console app using the Microsoft Change Feed library which makes things quite easy."),Object(r.b)("p",null,"Normally, I use WebJobs to handle queue processing and I do have a lot of experience with this. However, in .NET Core, the deployment of a WebJob is not very clear to me so I decided to write a stand-alone console app based on WebJobs SDK but can be deployed somewhere else."),Object(r.b)("p",null,"To host and deploy the two stand-alone .NET core console apps i.e. Change Feeder and Queue Processor, opted to make them Docker images and deploy them to a Kubernetes cluster."),Object(r.b)("h2",{id:"containerizing-the-webjobs-console-app"},"Containerizing the WebJobs Console App"),Object(r.b)("p",null,"I based my code on this ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"http://matt-roberts.me/azure-webjobs-in-net-core-2-with-di-and-configuration/"}),"blog post by Matt Roberts"),". My solution has several projects...but two are important for this step: ",Object(r.b)("inlineCode",{parentName:"p"},"AvalonWebJobs")," and ",Object(r.b)("inlineCode",{parentName:"p"},"AvalonWebDal"),". ",Object(r.b)("inlineCode",{parentName:"p"},"AvalonWebDal")," is a class library that has common functionality that I depend on. I used the following Docker file to build the WebJobs console app:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'FROM microsoft/dotnet:2.0-sdk as build\n\nWORKDIR /app\n\nCOPY . .\n\nWORKDIR /app/AvalonWebDal\nRUN dotnet restore\n\nWORKDIR /app/AvalonWebJobs\nRUN dotnet restore\n\nRUN dotnet publish --output /output --configuration Release\n\nFROM microsoft/dotnet:2.0-runtime\n\nCOPY --from=build /output /app\n\nWORKDIR /app\n\nENTRYPOINT [ "dotnet", "AvalonWebJobs.dll" ]\n')),Object(r.b)("p",null,"I used the following Docker command to build the image:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"docker build --file docketfile.webjobs --no-cache -t avalonwebjobs .\n")),Object(r.b)("p",null,"and the following to test locally:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"docker run --rm -ti avalonwebjobs\n")),Object(r.b)("h2",{id:"containerizing-the-change-feeder-app"},"Containerizing the Change Feeder App"),Object(r.b)("p",null,"I based my code on this ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed#change-feed-processor"}),"documentation post by Microsoft"),". My solution has several projects...but two are important for this step: ",Object(r.b)("inlineCode",{parentName:"p"},"AvalonChangeFeeder")," and ",Object(r.b)("inlineCode",{parentName:"p"},"AvalonWebDal"),". ",Object(r.b)("inlineCode",{parentName:"p"},"AvalonWebDal")," is a class library that has common functionality that I depend on. I used the following Docker file to build the WebJobs console app:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'FROM microsoft/dotnet:2.0-sdk as build\n\nWORKDIR /app\n\nCOPY . .\n\nWORKDIR /app/AvalonWebDal\nRUN dotnet restore\n\nWORKDIR /app/AvalonChangeFeeder\nRUN dotnet restore\n\nRUN dotnet publish --output /output --configuration Release\n\nFROM microsoft/dotnet:2.0-runtime\n\nCOPY --from=build /output /app\n\nWORKDIR /app\n\nENTRYPOINT [ "dotnet", "AvalonChangeFeeder.dll" ]\n')),Object(r.b)("p",null,"I used the following Docker command to build the image:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"docker build --file docketfile.changefeeder --no-cache -t avalonchangefeeder .\n")),Object(r.b)("p",null,"and the following to test locally:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"docker run --rm -ti avalonchangefeeder\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Important note:")),Object(r.b)("p",null,"Make sure that the ",Object(r.b)("inlineCode",{parentName:"p"},".csproj")," project file contains the following item groups so that the appsettings will be available in the container. Failure to do so will cause an error message ",Object(r.b)("inlineCode",{parentName:"p"},"unable to find appsettngs.json and it is not optional"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'<ItemGroup>\n    <None Remove="appsettings.json" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <Content Include="appsettings.json">\n      <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>\n    </Content>\n  </ItemGroup>\n')),Object(r.b)("h2",{id:"kubernetes"},"Kubernetes"),Object(r.b)("p",null,"I used ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough"}),"this documentation link")," to spawn a test 1-node k8s cluster in Azure. The process is really simple and quick. I tagged and published my two container images to an Azure Container Registry using ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli"}),"this documentaion link"),"."),Object(r.b)("p",null,"Now time to actually deploy to the k8s cluster. "),Object(r.b)("h3",{id:"deployments"},"Deployments"),Object(r.b)("p",null,"Becasue I wanted to scale the two web jobs and the change feeder separately, I opted to create two deployments: one for the web jobs and another for the change feeder. Alternatively, I could have used a two-pod deployment but this will have meant that my two containers will need to be scaled the same since the unit of scaling in k8s is the deployment ...not the pod. Please refer to ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://stackoverflow.com/questions/43217006/kubernetes-multi-pod-deployment"}),"this stack overflow issue")," for more information."),Object(r.b)("p",null,"I used the following ",Object(r.b)("inlineCode",{parentName:"p"},".yml")," file for the WebJobs k8s deployment:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: avalon-webjobs-deploy\nspec:\n  replicas: 1\n  minReadySeconds: 10\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: avalon-app\n    spec:\n      containers:\n      - name: avalon-webjobs-pod\n        image: avalonacr.azurecr.io/avalonwebjobs:v1\n        imagePullPolicy: Always\n")),Object(r.b)("p",null,"and the following ",Object(r.b)("inlineCode",{parentName:"p"},"kubectl")," command to deploy:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"kubectl create -f avalon-webjobs-app.yml\n")),Object(r.b)("p",null,"I used the following ",Object(r.b)("inlineCode",{parentName:"p"},".yml")," file for the Change feeder k8s deployment:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: avalon-changefeeder-deploy\nspec:\n  replicas: 1\n  minReadySeconds: 10\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: avalon-app\n    spec:\n      containers:\n      - name: avalon-changefeeder-pod\n        image: avalonacr.azurecr.io/avalonchangefeeder:v1\n        imagePullPolicy: Always\n")),Object(r.b)("p",null,"and the following ",Object(r.b)("inlineCode",{parentName:"p"},"kubectl")," command to deploy:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"kubectl create -f avalon-changefeeder-app.yml\n")),Object(r.b)("h3",{id:"observations"},"Observations"),Object(r.b)("p",null,"Initialy I set the number of replicas to one so I can make sure that everything is running well before I scale the k8s deployments."),Object(r.b)("p",null,"After the deployment as above, I used ",Object(r.b)("inlineCode",{parentName:"p"},"kubectl get pods")," to see the status of the nodes. I noticed that the webjobs pod is in ",Object(r.b)("inlineCode",{parentName:"p"},"running")," state (which is desired) while the change feeder container is in ",Object(r.b)("inlineCode",{parentName:"p"},"CrashLoopBackOff")," state. Humm....after some reasearch, I found ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://stackoverflow.com/questions/41604499/my-kubernetes-pods-keep-crashing-with-crashloopbackoff-but-i-cant-find-any-lo"}),"this helpful stack overflow issue"),". So I used the following command to see the actual console logs:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"kubectl logs avalon-changefeeder-deploy-1476356743-35g55  -c avalon-changefeeder-pod\n")),Object(r.b)("p",null,"After fiddling with it for a while, I discovered the problem has to do with how the change feeder console app was coded. It uses a typical ",Object(r.b)("inlineCode",{parentName:"p"},"Console.ReadKey")," method to make the application run until a key is pressed. So I modified my code based on ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://carlos.mendible.com/2017/10/15/prepare-a-net-core-console-app-for-docker/"}),"this useful code snippet"),", rebuild my container and re-deployed and yes....the change feeder pod is in ",Object(r.b)("inlineCode",{parentName:"p"},"running")," state."),Object(r.b)("p",null,"It took me a while to get the above to work. This is because I was updating the image in the container registry without changing the tag. This did not force a re-pull and I ended up not using the latest image that I was deploying to the container. It seems that k8s caches the images unless you add to the deployment file a ",Object(r.b)("inlineCode",{parentName:"p"},"imagePullPolicy: Always")," in the container spec. Doing so forces k8s to re-pull the image. The other option is to change the image tag."),Object(r.b)("p",null,"Now things look better ...but there is another problem. Upon termination, the change feeder container needs to de-register and clean up some resources. Unfortunately I noticed when I issue a ",Object(r.b)("inlineCode",{parentName:"p"},"docker stop <id>"),", the process is abruplty terminated and there is no change for the change feeder thread to clean up. I found a good article that describes how to ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/"}),"gracefully stop Docker containers")," which goes into some detail to describe the best way to handle it. However, since I am using a .NET Core app, I really did not find an easy way to handle the two Linux signales: ",Object(r.b)("inlineCode",{parentName:"p"},"SIGINT")," and ",Object(r.b)("inlineCode",{parentName:"p"},"SIGTERM"),". I did find a lot of discussions about it ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/aspnet/Hosting/issues/870"}),"here"),". As it stands now, if I run the container in an intercative mode using ",Object(r.b)("inlineCode",{parentName:"p"},"docker run --rm -ti avalonchangefeeder"),", for example, and then perform control-c or control-break, the container shuts down gracefully. However, if I issue a ",Object(r.b)("inlineCode",{parentName:"p"},"docker stop"),", the container abruplty exists without giving any chance for the change feeder to do any cleanup :-("),Object(r.b)("h2",{id:"application-insights"},"Application Insights"),Object(r.b)("p",null,"I used ",Object(r.b)("inlineCode",{parentName:"p"},"Application Insights")," to trace and track what is happening inside the container. This provide a really powerful way to monitor what is happening inside the container. I noticed that the Application Insights has a Kubernetes extension....but I am not using it yet."),Object(r.b)("h2",{id:"scaling"},"Scaling"),Object(r.b)("p",null,"Now that everything is in Kubernetes, we can scale the deployments up and down as we need. Scaling the web jobs deployment up to multiple replicas provide several consumers of the queue and scaling the change feeder deployment up to multiple replicas automatically adjusts the divide the work among themselves. "))}p.isMDXComponent=!0},138:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return h}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(n),u=o,h=b["".concat(i,".").concat(u)]||b[u]||d[u]||r;return n?a.a.createElement(h,s(s({ref:t},c),{},{components:n})):a.a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},166:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/avalon-architecture-4ebd1ec1a7a88f773c346fb24690235d.png"}}]);