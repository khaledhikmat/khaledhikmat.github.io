
<!DOCTYPE html>
<html lang="en">
        <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>

        <title>Khaled Hikmat - Actors in Serverless</title>
        <meta name="description" content="Coding Thoughts" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">        

        <link type="application/rss+xml" rel="alternate" title="Khaled Hikmat" href="/feed.rss" />
        <link type="application/atom+xml" rel="alternate" title="Khaled Hikmat" href="/feed.atom" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">

        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet" />
        <link href="/assets/css/highlight.css" rel="stylesheet">
        <link href="/assets/css/clean-blog.css" rel="stylesheet" />
        <link href="/assets/css/master.css" rel="stylesheet" />
        <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
        <link href="/assets/css/override.css" rel="stylesheet" />


        <meta name="application-name" content="Khaled Hikmat" />
        <meta name="msapplication-tooltip" content="Khaled Hikmat" />
        <meta name="msapplication-starturl" content="/" />

        <meta property="og:title" content="Khaled Hikmat - Actors in Serverless" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="http://khaledhikmat.github.io/posts/2017-12-27-durable-functions" />
        <!-- TODO: More social graph meta tags -->

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>     
        <script src="/assets/js/highlight.pack.js"></script>   
        <script src="/assets/js/clean-blog.js"></script>
        <script src="http://d3js.org/d3.v3.min.js"></script>
        <script src="/assets/js/trianglify.min.js"></script>
        <script src="/assets/js/Please-compressed.js"></script>
                
        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
                <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
                <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->


        </head>
        <body>
                
                <!-- Navigation -->
                <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
                        <div class="container-fluid">
                                <!-- Brand and toggle get grouped for better mobile display -->
                                <div class="navbar-header page-scroll">
                                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
                                        <span class="sr-only">Toggle navigation</span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        </button>
                                        <a class="navbar-brand" href="/">Khaled Hikmat</a>
                                </div>
                        
                                <!-- Collect the nav links, forms, and other content for toggling -->
                                <div class="collapse navbar-collapse" id="navbar-collapse">
                                        <ul class="nav navbar-nav navbar-right">
                                                <li><a href="/about">About</a></li>
<li><a href="/posts">Archive</a></li>
<li><a href="/tags">Tags</a></li> 
                                        </ul>
                                </div>
                                <!-- /.navbar-collapse -->
                        </div>
                        <!-- /.container -->
                </nav>
                
                <!-- Page Header -->
                <header class="intro-header" id="intro-header">
                        <div class="container">
                                <div class="row">
                                        <div class="col-md-12">

    
<div class="post-heading">
    <h1>Actors in Serverless</h1>
        <h2 class="subheading">Using Azure Functions</h2>
    <div class="meta">        
Published on Wednesday, December 27, 2017<br>    </div>
        <div class="tags">
                    <a role="button" href="/tags/net" class="btn btn-default btn-xs">.NET</a>
                    <a role="button" href="/tags/actors" class="btn btn-default btn-xs">Actors</a>
                    <a role="button" href="/tags/azure-functions" class="btn btn-default btn-xs">Azure Functions</a>
                    <a role="button" href="/tags/c%23" class="btn btn-default btn-xs">C#</a>
                    <a role="button" href="/tags/durable" class="btn btn-default btn-xs">Durable</a>
        </div>     
</div>
                                        </div>
                                </div>
                        </div>
                </header>
                
                <!-- Main Content -->
                <div class="container">
                        <div class="row">
                                <div id="content" class="col-md-12">
                                        

<p>I started with this <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-install">documentation page</a> to learn about Azure durable Functions. I wanted to know if I can build a way to implement actors in Azure Functions. Actors Programming Model is pretty interesting and I did some work on it <a href="http://khaledhikmat.github.io/posts/2016-12-15-service-fabric-fundamentals">here</a>, <a href="http://khaledhikmat.github.io/posts/2016-12-02-service-fabric-basics">here</a> and <a href="http://khaledhikmat.github.io/posts/2017-01-10-service-fabric-notes">here</a> using <a href="https://azure.microsoft.com/en-us/services/service-fabric/">Azure Service Fabric</a> before.</p>
<p>Following the Azure Functions sample instructions mentioned in the above link, I quickly got up and running. However, I wanted to answer the following questions about actors in Azure Functions:</p>
<ul>
<li>Create a new actor giving a provided actor id</li>
<li>Signal an existing actor to perform something</li>
<li>When do actors get created?</li>
<li>When do actors get terminated?</li>
<li>Can we read the actor's internal state</li>
<li>What about .NET Core and .NET Standard 2.0?</li>
</ul>
<h2 id="create-a-new-actor">Create a new actor:</h2>
<p>I created an HTTP trigger that looks like this where I provide a code that can be used as an instance id for the singleton i.e. membership actor. If the membership actor status is null or not running, then I start it with a <code>StartNewAsync</code>:</p>
<pre><code>[FunctionName(&quot;HttpRefreshMemberships&quot;)]
public static async Task&lt;HttpResponseMessage&gt; Run(
    [HttpTrigger(AuthorizationLevel.Function, methods: &quot;post&quot;, Route = &quot;memberships/refresh/{code}&quot;)] HttpRequestMessage req,
    [OrchestrationClient] DurableOrchestrationClient starter,
    string code,
    TraceWriter log)
{
    var membershipStatus = await starter.GetStatusAsync(code);
    string runningStatus = membershipStatus == null ? &quot;NULL&quot; : membershipStatus.RuntimeStatus.ToString();
    log.Info($&quot;Instance running status: '{runningStatus}'.&quot;);

    if (
        membershipStatus == null || 
        membershipStatus.RuntimeStatus != OrchestrationRuntimeStatus.Running
        )
    {
        var membership = new {
            Id = &quot;asas&quot;,
            Code = code,
            CardNumber = &quot;977515900121213&quot;
        };

        await starter.StartNewAsync(&quot;E3_Membership&quot;, code, membership);
        log.Info($&quot;Started a new membership actor with code = '{code}'.&quot;);
    }
    else
    {
        await starter.RaiseEventAsync(code, &quot;operation&quot;, &quot;refresh&quot;);
        log.Info($&quot;Refreshed an existing membership actor with code = '{code}'.&quot;);
    }

    var res = starter.CreateCheckStatusResponse(req, code);
    res.Headers.RetryAfter = new RetryConditionHeaderValue(TimeSpan.FromSeconds(10));
    return res;
}
</code></pre>
<h2 id="signal-an-existing-actor-to-perform-something">Signal an existing actor to perform something</h2>
<p>If the membership actor does exist, we raise a <code>refresh</code> event to wake up the singleton so it can do work:</p>
<pre><code>await starter.RaiseEventAsync(code, &quot;operation&quot;, &quot;refresh&quot;);
</code></pre>
<p>The actual membership actor code looks like this:</p>
<pre><code>public static class Membership
{
    [FunctionName(&quot;E3_Membership&quot;)]
    public static async Task&lt;dynamic&gt; Run(
        [OrchestrationTrigger] DurableOrchestrationContext context,
        TraceWriter log)
    {
        dynamic membership = context.GetInput&lt;dynamic&gt;();
        if (membership == null)
            log.Info($&quot;Something is bad! I should start with a valid membership.&quot;);

        var operation = await context.WaitForExternalEvent&lt;string&gt;(&quot;operation&quot;);
        log.Info($&quot;***** received '{operation}' event.&quot;);

        operation = operation?.ToLowerInvariant();
        if (operation == &quot;refresh&quot;)
        {
            membership = await Refresh(context, log);
        }

        if (operation != &quot;end&quot;)
        {
            context.ContinueAsNew(membership);
        }

        return membership;
    }

    public static async Task&lt;dynamic&gt; Refresh(DurableOrchestrationContext context,
                                              TraceWriter log)
    {
        // TODO: Do something to refresh the membership
        dynamic membership = new {
            Id = &quot;asas&quot;,
            Code = context.InstanceId,
            CardNumber = &quot;977515900121213&quot;
        };

        DateTime now = DateTime.Now;
        string formatDate = now.ToString(&quot;MM/dd/yyyy hh:mm:ss.fff tt&quot;);
        log.Info($&quot;**** done refreshing '{context.InstanceId}' &#64; {formatDate}&quot;);
        return membership;
    }
}
</code></pre>
<h3 id="multiple-signals">Multiple signals</h3>
<p>But what happens if the actor is signaled frantically via raising an external event from an HTTP trigger, for example? Well....initially I thought the event signals are actually enqueued to the instance so they should run as many  times as they are sginaled.</p>
<p>To try this, I started the functions app and triggered the refresh 3 times in a row via an HTTP trigger. From the log, I see that the <code>E3_Membership</code> for my instance id <code>U7TTR</code> was scheduled due to <code>RaiseEvent</code> 3 times as expected but was executed only once!! The (edited) log looks like this:</p>
<ul>
<li>Trigger 1:</li>
</ul>
<pre><code>[12/27/2017 5:19:19 PM] Executing HTTP request: {
[12/27/2017 5:19:19 PM]   &quot;requestId&quot;: null,
[12/27/2017 5:19:19 PM]   &quot;method&quot;: &quot;POST&quot;,
[12/27/2017 5:19:19 PM]   &quot;uri&quot;: &quot;/memberships/refresh/U7TTR&quot;
[12/27/2017 5:19:19 PM] }
[12/27/2017 5:19:19 PM] Function started (Id=35d4e63e-1797-4c55-abe8-40d4acb45457)
[12/27/2017 5:19:19 PM] Executing 'HttpRefreshMemberships' (Reason='This function was programmatically called via the host APIs.', Id=35d4e63e-1797-4c55-abe8-40d4acb45457)
[12/27/2017 5:19:19 PM] Instance running status: 'Running'.
[12/27/2017 5:19:20 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' scheduled. Reason: RaiseEvent:operation. IsReplay: False. State: Scheduled. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:20 PM] Refreshed an existing membership actor with code = 'U7TTR'.
[12/27/2017 5:19:20 PM] Function completed (Success, Id=35d4e63e-1797-4c55-abe8-40d4acb45457, Duration=968ms)
[12/27/2017 5:19:20 PM] Executed 'HttpRefreshMemberships' (Succeeded, Id=35d4e63e-1797-4c55-abe8-40d4acb45457)
[12/27/2017 5:19:20 PM] Executed HTTP request: {
[12/27/2017 5:19:20 PM]   &quot;requestId&quot;: &quot;304f872e-a276-4437-b127-0a58948b8e83&quot;,
[12/27/2017 5:19:20 PM]   &quot;method&quot;: &quot;POST&quot;,
[12/27/2017 5:19:20 PM]   &quot;uri&quot;: &quot;/memberships/refresh/U7TTR&quot;,
[12/27/2017 5:19:20 PM]   &quot;authorizationLevel&quot;: &quot;Anonymous&quot;
[12/27/2017 5:19:20 PM] }
[12/27/2017 5:19:20 PM] Response details: {
[12/27/2017 5:19:20 PM]   &quot;requestId&quot;: &quot;304f872e-a276-4437-b127-0a58948b8e83&quot;,
[12/27/2017 5:19:20 PM]   &quot;status&quot;: &quot;Accepted&quot;
[12/27/2017 5:19:20 PM] }
</code></pre>
<ul>
<li>Trigger 2:</li>
</ul>
<pre><code>[12/27/2017 5:19:20 PM] Executing HTTP request: {
[12/27/2017 5:19:20 PM]   &quot;requestId&quot;: null,
[12/27/2017 5:19:20 PM]   &quot;method&quot;: &quot;POST&quot;,
[12/27/2017 5:19:20 PM]   &quot;uri&quot;: &quot;/memberships/refresh/U7TTR&quot;
[12/27/2017 5:19:20 PM] }
[12/27/2017 5:19:21 PM] Function started (Id=bcbe86a7-8da5-4f81-ab29-0a334f5fd88c)
[12/27/2017 5:19:21 PM] Executing 'HttpRefreshMemberships' (Reason='This function was programmatically called via the host APIs.', Id=bcbe86a7-8da5-4f81-ab29-0a334f5fd88c)
[12/27/2017 5:19:21 PM] Instance running status: 'Running'.
[12/27/2017 5:19:21 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' scheduled. Reason: RaiseEvent:operation. IsReplay: False. State: Scheduled. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:21 PM] Refreshed an existing membership actor with code = 'U7TTR'.
[12/27/2017 5:19:21 PM] Function completed (Success, Id=bcbe86a7-8da5-4f81-ab29-0a334f5fd88c, Duration=475ms)
[12/27/2017 5:19:21 PM] Executed 'HttpRefreshMemberships' (Succeeded, Id=bcbe86a7-8da5-4f81-ab29-0a334f5fd88c)
[12/27/2017 5:19:21 PM] Executed HTTP request: {
[12/27/2017 5:19:21 PM]   &quot;requestId&quot;: &quot;542f35d6-467f-4959-9e0e-e4ac0f7b74e1&quot;,
[12/27/2017 5:19:21 PM]   &quot;method&quot;: &quot;POST&quot;,
[12/27/2017 5:19:21 PM]   &quot;uri&quot;: &quot;/memberships/refresh/U7TTR&quot;,
[12/27/2017 5:19:21 PM]   &quot;authorizationLevel&quot;: &quot;Anonymous&quot;
[12/27/2017 5:19:21 PM] }
[12/27/2017 5:19:21 PM] Response details: {
[12/27/2017 5:19:21 PM]   &quot;requestId&quot;: &quot;542f35d6-467f-4959-9e0e-e4ac0f7b74e1&quot;,
[12/27/2017 5:19:21 PM]   &quot;status&quot;: &quot;Accepted&quot;
[12/27/2017 5:19:21 PM] }
</code></pre>
<ul>
<li>Trigger 3:</li>
</ul>
<pre><code>[12/27/2017 5:19:22 PM] Executing HTTP request: {
[12/27/2017 5:19:22 PM]   &quot;requestId&quot;: null,
[12/27/2017 5:19:22 PM]   &quot;method&quot;: &quot;POST&quot;,
[12/27/2017 5:19:22 PM]   &quot;uri&quot;: &quot;/memberships/refresh/U7TTR&quot;
[12/27/2017 5:19:22 PM] }
[12/27/2017 5:19:22 PM] Function started (Id=c4679277-83ed-4a25-a1d3-46d558dad7d3)
[12/27/2017 5:19:22 PM] Executing 'HttpRefreshMemberships' (Reason='This function was programmatically called via the host APIs.', Id=c4679277-83ed-4a25-a1d3-46d558dad7d3)
[12/27/2017 5:19:22 PM] Instance running status: 'Running'.
[12/27/2017 5:19:22 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' scheduled. Reason: RaiseEvent:operation. IsReplay: False. State: Scheduled. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:22 PM] Refreshed an existing membership actor with code = 'U7TTR'.
[12/27/2017 5:19:22 PM] Function completed (Success, Id=c4679277-83ed-4a25-a1d3-46d558dad7d3, Duration=474ms)
[12/27/2017 5:19:22 PM] Executed 'HttpRefreshMemberships' (Succeeded, Id=c4679277-83ed-4a25-a1d3-46d558dad7d3)
[12/27/2017 5:19:22 PM] Executed HTTP request: {
[12/27/2017 5:19:22 PM]   &quot;requestId&quot;: &quot;a330a5c7-6f2a-41d7-80c6-5ca6d2928a64&quot;,
[12/27/2017 5:19:22 PM]   &quot;method&quot;: &quot;POST&quot;,
[12/27/2017 5:19:22 PM]   &quot;uri&quot;: &quot;/memberships/refresh/U7TTR&quot;,
[12/27/2017 5:19:22 PM]   &quot;authorizationLevel&quot;: &quot;Anonymous&quot;
[12/27/2017 5:19:22 PM] }
[12/27/2017 5:19:22 PM] Response details: {
[12/27/2017 5:19:22 PM]   &quot;requestId&quot;: &quot;a330a5c7-6f2a-41d7-80c6-5ca6d2928a64&quot;,
[12/27/2017 5:19:22 PM]   &quot;status&quot;: &quot;Accepted&quot;
[12/27/2017 5:19:22 PM] }
</code></pre>
<ul>
<li>Membership Actor: please note that the function is actually executed twice: once to handle the event and anoher time due to the <code>ContinueAsNew</code> which restarts the instance with a new history.</li>
</ul>
<pre><code>============ Received an event .....
[12/27/2017 5:19:25 PM] Function started (Id=d676aacb-069d-4b10-869c-bb510b70d65e)
[12/27/2017 5:19:25 PM] Executing 'E3_Membership' (Reason='', Id=d676aacb-069d-4b10-869c-bb510b70d65e)
[12/27/2017 5:19:25 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' started. IsReplay: True. Input: (720 bytes). State: Started. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:25 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' is waiting for input. Reason: WaitForExternalEvent:operation. IsReplay: True. State: Listening. HubName: SampleHubVS. AppName: . SlotName: .  ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:25 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' received a 'operation' event. State: ExternalEventRaised. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:25 PM] ***** received 'refresh' event.
[12/27/2017 5:19:25 PM] **** done refreshing 'U7TTR' &#64; 12/27/2017 09:19:25.837 PM
[12/27/2017 5:19:25 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' completed. ContinuedAsNew: True. IsReplay: False. Output: (236 bytes). State: Completed. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:25 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' received a 'operation' event. State: ExternalEventRaised. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:25 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' received a 'operation' event. State: ExternalEventRaised. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:25 PM] Function completed (Success, Id=d676aacb-069d-4b10-869c-bb510b70d65e, Duration=24ms)
[12/27/2017 5:19:25 PM] Executed 'E3_Membership' (Succeeded, Id=d676aacb-069d-4b10-869c-bb510b70d65e)

============ ContinueAsNew kicking in.....
[12/27/2017 5:19:26 PM] Function started (Id=50870a65-6d4d-4680-95a0-8dea2388e054)
[12/27/2017 5:19:26 PM] Executing 'E3_Membership' (Reason='', Id=50870a65-6d4d-4680-95a0-8dea2388e054)
[12/27/2017 5:19:26 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' started. IsReplay: False. Input: (720 bytes). State: Started. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:26 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' is waiting for input. Reason: WaitForExternalEvent:operation. IsReplay: False. State: Listening. HubName: SampleHubVS. AppName: . SlotName: .  ExtensionVersion: 1.1.0.0.
[12/27/2017 5:19:26 PM] Function completed (Success, Id=50870a65-6d4d-4680-95a0-8dea2388e054, Duration=9ms)
[12/27/2017 5:19:26 PM] Executed 'E3_Membership' (Succeeded, Id=50870a65-6d4d-4680-95a0-8dea2388e054)
[12/27/2017 5:19:26 PM] U7TTR: Function 'E3_Membership (Orchestrator)', version '' awaited. IsReplay: False. State: Awaited. HubName: SampleHubVS. AppName: . SlotName: . ExtensionVersion: 1.1.0.0.
</code></pre>
<p>If I try several triggers, I see different results. One thing for sure is that if the triggers arrive close to each other, the actor exceution is not very deterministic. Perhaps this is by design...not really sure.</p>
<h3 id="code-delays">Code Delays</h3>
<p>Singletons cannot use Task functions such as <code>task.Delay(millis)</code> to simulate code delays. This will cause run-time errors:</p>
<pre><code>Function 'E3_Membership (Orchestrator)', version '' failed with an error. Reason: System.InvalidOperationException: Multithreaded execution was detected. his can happen if the orchestrator function previously resumed from an unsupported async callback.
</code></pre>
<p>The preferred way for delays or timeouts is:</p>
<pre><code>await context.CreateTimer(deadline, CancellationToken.None);
</code></pre>
<h3 id="wait-on-multiple-events">Wait on multiple events</h3>
<p>What if we want the actor to wait on an external event or on a internal timeout event to perhaps refresh our membership periodically? I created another membership function i.e. <code>E3_MembershipWithTimer</code> that awaits on either an operation event or a timeout event:</p>
<pre><code>[FunctionName(&quot;E3_MembershipWithTimer&quot;)]
public static async Task&lt;dynamic&gt; RunWithTimer(
    [OrchestrationTrigger] DurableOrchestrationContext context,
    TraceWriter log)
{
    log.Info($&quot;E3_MembershipWithTimer starting.....&quot;);
    dynamic membership = context.GetInput&lt;dynamic&gt;();
    if (membership == null)
        log.Info($&quot;Something is bad! I should start with a valid membership.&quot;);

    string operation = &quot;refresh&quot;;
    using (var cts = new CancellationTokenSource())
    {
        var operationTask = context.WaitForExternalEvent&lt;string&gt;(&quot;operation&quot;);
        DateTime deadline = context.CurrentUtcDateTime.Add(TimeSpan.FromSeconds(60));
        var timeoutTask = context.CreateTimer(deadline, cts.Token);

        Task winner = await Task.WhenAny(operationTask, timeoutTask);
        if (winner == operationTask)
        {
            log.Info($&quot;An operation event received!&quot;);
            operation = operationTask.Result;
            cts.Cancel();
        }
        else
        {
            // Default the timeout task to mean a 'refresh' operation
            log.Info($&quot;A timeout event received!&quot;);
            operation = &quot;refresh&quot;;
        }
    }

    log.Info($&quot;***** received '{operation}' event.&quot;);

    operation = operation?.ToLowerInvariant();
    if (operation == &quot;refresh&quot;)
    {
        membership = await Refresh(context, log);
    }

    if (operation != &quot;end&quot;)
    {
        context.ContinueAsNew(membership);
    }

    return membership;
}
</code></pre>
<h2 id="when-do-actors-get-created">When do actors get created?</h2>
<p>Actors or singletons actually do persist in storage (please see the section about termination)......this is how an Azure Functions knows how to start them when it restarts. So if you create actors with specific instance ids (or actor ids), shut down the functions and restart it, the singleton instances are available. When you want to trigger an instance, you must check its running state and then invoke the proper API:</p>
<pre><code>var membershipStatus = await starter.GetStatusAsync(code);
string runningStatus = membershipStatus == null ? &quot;NULL&quot; : membershipStatus.RuntimeStatus.ToString();
log.Info($&quot;Instance running status: '{runningStatus}'.&quot;);

if (
    membershipStatus == null || 
    membershipStatus.RuntimeStatus != OrchestrationRuntimeStatus.Running
    )
{
    var membership = new {
        Id = &quot;asas&quot;,
        Code = code,
        CardNumber = &quot;977515900121213&quot;
    };

    await starter.StartNewAsync(&quot;E3_Membership&quot;, code, membership);
    log.Info($&quot;Started a new membership actor with code = '{code}'.&quot;);
}
else
{
    await starter.RaiseEventAsync(code, &quot;operation&quot;, &quot;refresh&quot;);
    log.Info($&quot;Refreshed an existing membership actor with code = '{code}'.&quot;);
}
</code></pre>
<h2 id="when-do-actors-get-terminated">When do actors get terminated?</h2>
<p>They can be easily terminated using the <code>TerminateAsync</code> API. So I created a little HTTP trugger that would terminate instances:</p>
<pre><code>[FunctionName(&quot;HttpTerminateMemberships&quot;)]
public static async Task&lt;HttpResponseMessage&gt; Run(
    [HttpTrigger(AuthorizationLevel.Function, methods: &quot;post&quot;, Route = &quot;memberships/terminate/{code}&quot;)] HttpRequestMessage req,
    [OrchestrationClient] DurableOrchestrationClient starter,
    string code,
    TraceWriter log)
{
    try
    {
        await starter.TerminateAsync(code, &quot;&quot;);
        return req.CreateResponse&lt;dynamic&gt;(HttpStatusCode.OK);
    }
    catch (Exception ex)
    {
        return req.CreateResponse&lt;dynamic&gt;(HttpStatusCode.BadRequest, ex.Message);
    }
}
</code></pre>
<p>The Azure Durable Functions maintain a state of all running instances in a task hub which is basically a storage resource with control queues, qork-item queues, a history table and lease blobs. You can read more about this <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-task-hubs">here</a>.</p>
<h2 id="the-actor-state">The actor state</h2>
<p>Each actor has an internal state! It is initially read by the singleton as an input:</p>
<pre><code>dynamic membership = context.GetInput&lt;dynamic&gt;();
</code></pre>
<p>and it is updated using:</p>
<pre><code>context.ContinueAsNew(membership);
</code></pre>
<p>But it seems that the internal state is actually not persisted anywhere ...it is transient. When actors are initially created, a state is passed as an input i.e. <code>context.GetInput&lt;dynamic&gt;()</code> and the actor updates it with a call to <code>ContinueAsNew</code> which actually restarts itself with a new state.</p>
<p>I also could not find a way for an HTTP trigger to read the internal state of an actor.</p>
<p>Given that, I think the internal state seems to be used only for the actor internal operation. If an actor is to expose its state, it must be saved externally so HTTP triggers, for example, can read it directly from the external store.</p>
<p>One way of doing this is to modify the code to look something like this:</p>
<pre><code>[FunctionName(&quot;HttpRefreshMemberships&quot;)]
public static async Task&lt;HttpResponseMessage&gt; Run(
    [HttpTrigger(AuthorizationLevel.Function, methods: &quot;post&quot;, Route = &quot;memberships/refresh/{code}&quot;)] HttpRequestMessage req,
    [OrchestrationClient] DurableOrchestrationClient starter,
    string code,
    TraceWriter log)
{
    var membershipStatus = await starter.GetStatusAsync(code);
    string runningStatus = membershipStatus == null ? &quot;NULL&quot; : membershipStatus.RuntimeStatus.ToString();
    log.Info($&quot;Instance running status: '{runningStatus}'.&quot;);

    if (
        membershipStatus == null || 
        membershipStatus.RuntimeStatus != OrchestrationRuntimeStatus.Running
        )
    {
		// Given the membership code, read from an external source
        var membership = await RetriveFromCosmosDB(code);
        await starter.StartNewAsync(&quot;E3_Membership&quot;, code, membership);
        log.Info($&quot;Started a new membership actor with code = '{code}'.&quot;);
    }
    else
    {
        await starter.RaiseEventAsync(code, &quot;operation&quot;, &quot;refresh&quot;);
        log.Info($&quot;Refreshed an existing membership actor with code = '{code}'.&quot;);
    }

    var res = starter.CreateCheckStatusResponse(req, code);
    res.Headers.RetryAfter = new RetryConditionHeaderValue(TimeSpan.FromSeconds(10));
    return res;
}
</code></pre>
<p>and the membership actor:</p>
<pre><code>public static class Membership
{
    [FunctionName(&quot;E3_Membership&quot;)]
    public static async Task&lt;dynamic&gt; Run(
        [OrchestrationTrigger] DurableOrchestrationContext context,
        TraceWriter log)
    {
        dynamic membership = context.GetInput&lt;dynamic&gt;();
        if (membership == null)
		{
            // Read from an external source 
            membership = await RetriveFromCosmosDB(context.InstanceId);
		}

        var operation = await context.WaitForExternalEvent&lt;string&gt;(&quot;operation&quot;);
        log.Info($&quot;***** received '{operation}' event.&quot;);

        operation = operation?.ToLowerInvariant();
        if (operation == &quot;refresh&quot;)
        {
            membership = await Refresh(context, log);
        }

        if (operation != &quot;end&quot;)
        {
            context.ContinueAsNew(membership);
        }

        return membership;
    }

    public static async Task&lt;dynamic&gt; Refresh(DurableOrchestrationContext context,
                                              TraceWriter log)
    {
        // TODO: Do something to refresh the membership
        dynamic membership = new {
            Id = &quot;asas&quot;,
            Code = context.InstanceId,
            CardNumber = &quot;977515900121213&quot;
        };

		// TODO: Store to an external source
        await StoreToCosmosDB(context.InstanceId, membership);

        DateTime now = DateTime.Now;
        string formatDate = now.ToString(&quot;MM/dd/yyyy hh:mm:ss.fff tt&quot;);
        log.Info($&quot;**** done refreshing '{context.InstanceId}' &#64; {formatDate}&quot;);
        return membership;
    }
}
</code></pre>
<p>and the HTTP trigger that retrieves the membership actor state from an extenal source without dealing with the actor:</p>
<pre><code>[FunctionName(&quot;HttpGetMembership&quot;)]
public static async Task&lt;HttpResponseMessage&gt; Run(
    [HttpTrigger(AuthorizationLevel.Function, methods: &quot;get&quot;, Route = &quot;memberships/{code}&quot;)] HttpRequestMessage req,
    [OrchestrationClient] DurableOrchestrationClient starter,
    string code,
    TraceWriter log)
{
    var status = await starter.GetStatusAsync(code);
    if (status != null)
    {
        return req.CreateResponse&lt;dynamic&gt;(HttpStatusCode.OK, await RetriveFromCosmosDB(code));
    }
    else
    {
        return req.CreateResponse&lt;dynamic&gt;(HttpStatusCode.BadRequest, $&quot;{code} membership actor is not found!&quot;);
    }
}
</code></pre>
<p>So unlike regular actor implementation, Azure Functions singletons do not expose any method to be called from the outside! The platform only allows starting/creating, querying and terminating instances.</p>
<h2 id="net-standard-2.0">.NET Standard 2.0</h2>
<p>It is work in progress! It is best to use the .NET full framework with Azure Functions. Hopefully this will change soon and we will be able to use .NET Core reliably.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Reflecting on the little time that I spent with Azure Durable Functions, I think they will play an important part of my future solutions. I think they have what it takes to use as actors minus the internal state. If we externalize their state, we will be able to query the external store as opposed to query the actors themselves to retrieve their state.</p>
<p>Azure Durable Actors can also employ reminders and other sophisticated techniques found in Service Fabric actors such as long-running, stateful, single-threaded, location-transparent and globally addressable (taken from the overview <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview">documentation page</a>). However, as stated above, Azure Functions singletons do not expose methods that can be called from the outside.</p>



                                </div>
                        </div>
                </div>
                
                <hr>
                
                <!-- Footer -->
                <footer>
                        <div class="container">
        <div class="row">
                <div class="col-md-12">
                <ul class="list-inline text-center">
                        <li>
                        <a href="https://twitter.com/khaledhmat">
                                <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                        </li>
                        <li>
                        <a href="https://github.com/khaledhikmat">
                                <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                        </li>
                </ul>
                <p class="copyright text-muted">
                        Copyright © 2017 by Khaled Hikmat. 
                        <br />
                        <strong><a href="http://wyam.io">Generated by Wyam</a></strong>
                </p>
                </div>
        </div>
</div>
                </footer> 

                <script type="text/javascript">
</script>
                <script>hljs.initHighlightingOnLoad();</script>

                        <script type="text/javascript">                
                                // Header background                        
                                var colors = Please.make_color({
                                        colors_returned: 3,
                                        saturation: .6
                                });
                                var t = new Trianglify({
                                        x_gradient: colors,
                                        y_gradient: ["#FFFFFF"]
                                });
                                var header = document.getElementById("intro-header");
                                var pattern = t.generate(header.clientWidth, header.clientHeight);
                                header.setAttribute('style', 'background-image: ' + pattern.dataUrl);                        
                        </script>
        </body>
</html>

