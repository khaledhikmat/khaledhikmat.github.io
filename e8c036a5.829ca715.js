(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{129:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return o})),a.d(t,"toc",(function(){return s})),a.d(t,"default",(function(){return p}));var i=a(3),n=a(7),r=(a(0),a(138)),c={title:"Service Fabric Basics",author:"Khaled Hikmat",author_title:"Software Engineer",author_url:"https://github.com/khaledhikmat",author_image_url:"https://avatars1.githubusercontent.com/u/3119726?s=400&u=090899e7b366dd702f9d0d5e483f20089010b25c&v=4",tags:["Service Fabric"]},o={permalink:"/blog/2016/12/02/service-fabric-basics",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/blog/blog/2016-12-02-service-fabric-basics.md",source:"@site/blog/2016-12-02-service-fabric-basics.md",description:"Service Fabric is a cool technology from Microsoft! It has advanced features that allows many scenarios. But in this post, we will only cover basic concepts that are usually misunderstood by a lot of folks.",date:"2016-12-02T00:00:00.000Z",tags:[{label:"Service Fabric",permalink:"/blog/tags/service-fabric"}],title:"Service Fabric Basics",readingTime:13.095,truncated:!1,prevItem:{title:"Service Fabric Fundamentals",permalink:"/blog/2016/12/15/service-fabric-fundamentals"},nextItem:{title:"Xamarin Forms App using VS for mac",permalink:"/blog/2016/11/24/presentation-evaluation"}},s=[{value:"Guest Service",id:"guest-service",children:[]},{value:"Application Package",id:"application-package",children:[{value:"The root folder",id:"the-root-folder",children:[]},{value:"The service folder",id:"the-service-folder",children:[]}]},{value:"Deployment",id:"deployment",children:[]},{value:"Availability",id:"availability",children:[]},{value:"Cleanup",id:"cleanup",children:[]},{value:"Versions &amp; Upgrade",id:"versions--upgrade",children:[{value:"The Application Manifest",id:"the-application-manifest",children:[]},{value:"The Service Manifest",id:"the-service-manifest",children:[]},{value:"Deployment",id:"deployment-1",children:[]},{value:"Upgrade",id:"upgrade",children:[]}]},{value:"Updates",id:"updates",children:[]},{value:"Better High Availability",id:"better-high-availability",children:[{value:"The Service Manifest",id:"the-service-manifest-1",children:[]},{value:"The Monitor Service",id:"the-monitor-service",children:[]},{value:"Console Outputs in the local cluster",id:"console-outputs-in-the-local-cluster",children:[]}]},{value:"What is next?",id:"what-is-next",children:[]}],l={toc:s};function p(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},l,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Service Fabric is a cool technology from Microsoft! It has advanced features that allows many scenarios. But in this post, we will only cover basic concepts that are usually misunderstood by a lot of folks."),Object(r.b)("p",null,"For the purpose of this demo, we are going to develop a very basic guest executable service written as a console app. We will use very basic application and service manifests and PowerShell script to deploy to Service Fabric and show how Service Fabric monitors services, reports their health and allows for upgrade and update. "),Object(r.b)("p",null,"The source code for this post is available ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"/blog/2016/12/02/service-fabric-basics"}),"here"),". Most of the code and ideas are credited to Jeff Richter of the Service Fabric Team."),Object(r.b)("h2",{id:"guest-service"},"Guest Service"),Object(r.b)("p",null,"The Guest service is a basic ",Object(r.b)("inlineCode",{parentName:"p"},"Win32")," console app that invokes an ",Object(r.b)("inlineCode",{parentName:"p"},"HttpListener")," on a port that is passed in the argument. The little web server responds to requests like so:"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/YqTjqBD.png",alt:"Web Server"}))),Object(r.b)("p",null,"Note that the service is NOT running the Service Fabric cluster."),Object(r.b)("p",null,"That is it!! This simple web server accepts a command called ",Object(r.b)("inlineCode",{parentName:"p"},"crash")," which will kill the service completely:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"http://localhost:8800?cmd=crash\n")),Object(r.b)("p",null,"In fact, it does support multiple commands:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),'var command = request.QueryString["cmd"];\nif (!string.IsNullOrEmpty(command))\n{\n    switch (command.ToLowerInvariant())\n    {\n        case "delay":\n            Int32.TryParse(request.QueryString["delay"], out _delay);\n            break;\n        case "crash":\n            Environment.Exit(-1);\n            break;\n    }\n}\n')),Object(r.b)("p",null,"In order to make this service highly available, let us see how we can package this service to run within Service Fabric. Please note that this service is not cognizant of any Service Fabric. It is purely a simple ",Object(r.b)("inlineCode",{parentName:"p"},"Win32")," service written as a console app."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Please note:")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"To debug the service locally from Visual Studio, you need to start VS in administrator mode."),Object(r.b)("li",{parentName:"ul"},"Service Fabric requires the projects be ",Object(r.b)("inlineCode",{parentName:"li"},"X64"),"! So you must change your projects to use ",Object(r.b)("inlineCode",{parentName:"li"},"X64")," by using the Visual Studio Configuration Manager.")),Object(r.b)("h2",{id:"application-package"},"Application Package"),Object(r.b)("p",null,"Application Package in Service Fabric is nothing but a folder that contains certain manifests in specific sub-folders! We will build the directory by hand instead of using Visual Studio so we can find out exactly how to do these steps. Let us create a directory called ",Object(r.b)("inlineCode",{parentName:"p"},"BasicAvailabilityApp")," (i.e.  ",Object(r.b)("inlineCode",{parentName:"p"},"c:\\BasicAvailabilityApp"),") to describe the Service Fabric application. "),Object(r.b)("h3",{id:"the-root-folder"},"The root folder"),Object(r.b)("p",null,"The root folder contains the application manifest and a sub-folder for each service in contains. Here is how the application manifest looks like for this demo application:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-xml"}),'<?xml version="1.0" encoding="utf-8"?>\n<ApplicationManifest ApplicationTypeName="BasicAvailabilityAppType" ApplicationTypeVersion="1.0.0"\n                     xmlns:xsd="http://www.w3.org/2001/XMLSchema" \n                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \n                     xmlns="http://schemas.microsoft.com/2011/01/fabric">\n   <ServiceManifestImport>\n      <ServiceManifestRef ServiceManifestName="CrashableServiceTypePkg" ServiceManifestVersion="1.0.0" />\n   </ServiceManifestImport>\n</ApplicationManifest>\n')),Object(r.b)("p",null,"There are several pieces of information in this manifest:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"The application type: ",Object(r.b)("inlineCode",{parentName:"li"},"BasicAvailabilityAppType"),"."),Object(r.b)("li",{parentName:"ul"},"The application version: ",Object(r.b)("inlineCode",{parentName:"li"},"1.0.0"),"."),Object(r.b)("li",{parentName:"ul"},"The application contains a single service type ",Object(r.b)("inlineCode",{parentName:"li"},"CrashableServiceTypePkg")," with version ",Object(r.b)("inlineCode",{parentName:"li"},"1.0.0"),"."),Object(r.b)("li",{parentName:"ul"},"The XML name spaces are not important to us.")),Object(r.b)("p",null,"This is how the application folder looks like: "),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/VMARUS3.png",alt:"Root Application Folder"}))),Object(r.b)("h3",{id:"the-service-folder"},"The service folder"),Object(r.b)("p",null,"The service folder contains the service manifest and a sub-folder for each service in contains. Here is how the application manifest looks like for this demo application:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-xml"}),'<?xml version="1.0" encoding="utf-8"?>\n<ServiceManifest Name="CrashableServiceTypePkg"\n                 Version="1.0.0"\n                 xmlns="http://schemas.microsoft.com/2011/01/fabric"\n                 xmlns:xsd="http://www.w3.org/2001/XMLSchema"\n                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n  <ServiceTypes>\n    <StatelessServiceType ServiceTypeName="CrashableServiceType" UseImplicitHost="true" />\n  </ServiceTypes>\n\n  <CodePackage Name="CrashableCodePkg" Version="1.0.0">\n    <EntryPoint>\n      <ExeHost>\n        <Program>CrashableService.exe</Program>\n        <Arguments>8800</Arguments>\n      </ExeHost>\n    </EntryPoint>\n  </CodePackage>\n\n  \x3c!-- ACL the 8800 port where the crashable service listens --\x3e\n  <Resources>\n    <Endpoints>\n      <Endpoint Name="InputEndpoint" Port="8800" Protocol="http" Type="Input" />\n    </Endpoints>\n  </Resources>\n</ServiceManifest>\n')),Object(r.b)("p",null,"There are several pieces of information in this manifest:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"The service package: ",Object(r.b)("inlineCode",{parentName:"li"},"CrashableServiceTypePkg"),"."),Object(r.b)("li",{parentName:"ul"},"The service version: ",Object(r.b)("inlineCode",{parentName:"li"},"1.0.0"),"."),Object(r.b)("li",{parentName:"ul"},"The service type: ",Object(r.b)("inlineCode",{parentName:"li"},"CrashableServiceType"),"."),Object(r.b)("li",{parentName:"ul"},"The service type is stateless."),Object(r.b)("li",{parentName:"ul"},"The service code package exists in a sub-folder called ",Object(r.b)("inlineCode",{parentName:"li"},"CodePkg")," and it is of version ",Object(r.b)("inlineCode",{parentName:"li"},"1.0.0"),"."),Object(r.b)("li",{parentName:"ul"},"The service code consists of an executable called ",Object(r.b)("inlineCode",{parentName:"li"},"CrashableService.exe"),"."),Object(r.b)("li",{parentName:"ul"},"The XML name spaces are not important to us."),Object(r.b)("li",{parentName:"ul"},"The ",Object(r.b)("inlineCode",{parentName:"li"},"Endoints")," must be specified to allow the Service Fabric to ",Object(r.b)("inlineCode",{parentName:"li"},"ACL")," the port that we want opened for our service to listen on. The ",Object(r.b)("inlineCode",{parentName:"li"},"Input")," type instructs SF to accepts input from the Internet.")),Object(r.b)("p",null,"This is how the service folder looks like: "),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/0bA48hy.png",alt:"service Folder"}))),Object(r.b)("p",null,"This is what it takes to package an application in Service Fabric. "),Object(r.b)("h2",{id:"deployment"},"Deployment"),Object(r.b)("p",null,"Please note that the package we created in the previous step needs to be deployed to Service Fabric in order to run. To do this, we will need to use either Visual Studio or PowerShell. Since we want to use the lower level commands, we will use PowerShell instead of Visual Studio:"),Object(r.b)("p",null,"Here is the PowerShell script that we can use:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),'# Define equates (hard-coded):\n$clusterUrl = "localhost"\n$imageStoreConnectionString = "file:C:\\SfDevCluster\\Data\\ImageStoreShare" \n$appPkgName = "BasicAvailabilityAppTypePkg"\n$appTypeName = "BasicAvailabilityAppType"\n$appName = "fabric:/BasicAvailabilityApp"\n$serviceTypeName = "CrashableServiceType"\n$serviceName = $appName + "/CrashableService"\n\n# Connect PowerShell session to a cluster\nConnect-ServiceFabricCluster -ConnectionEndpoint ${clusterUrl}:19000\n\n# Copy the application package to the cluster\nCopy-ServiceFabricApplicationPackage -ApplicationPackagePath "BasicAvailabilityApp" -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Register the application package\'s application type/version\nRegister-ServiceFabricApplicationType -ApplicationPathInImageStore $appPkgName\n\n# After registering the package\'s app type/version, you can remove the package from the cluster image store\nRemove-ServiceFabricApplicationPackage -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Create a named application from the registered app type/version\nNew-ServiceFabricApplication -ApplicationTypeName $appTypeName -ApplicationTypeVersion "1.0.0" -ApplicationName $appName \n\n# Create a named service within the named app from the service\'s type\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $serviceTypeName -ServiceName $serviceName -Stateless -PartitionSchemeSingleton -InstanceCount 1\n\n')),Object(r.b)("p",null,"The key commands are the last two where we:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Create a named application name from the registered application type and version:")),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),'# Create a named application from the registered app type/version\nNew-ServiceFabricApplication -ApplicationTypeName $appTypeName -ApplicationTypeVersion "1.0.0" -ApplicationName $appName \n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Create a named service within the named app from the service type:")),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"# Create a named service within the named app from the service's type\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $serviceTypeName -ServiceName $serviceName -Stateless -PartitionSchemeSingleton -InstanceCount 1\n")),Object(r.b)("p",null,"This is extremely significant as it allows us to create multiple application instances within the same cluster and each named application instance has its own set of services. This is how the named application and services are related to the cluster (this is taken from Service Fabric team presentation):"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/377RP4J.png",alt:"Naming Stuff"}))),Object(r.b)("p",null,"Once the named application and the named service are deployed, the Service Fabric explorer shows it like this:"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/tTLgIMX.png",alt:"Success Deployment"}))),Object(r.b)("p",null,"Now, if we access the service in Service Fabric, we will get a response that clearly indicates that the service is indeed running in Service Fabric:"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/AI9jYOV.png",alt:"Deployed in SF"}))),Object(r.b)("p",null,"Note that the service is running in Node 1 of the Service Fabric cluster."),Object(r.b)("h2",{id:"availability"},"Availability"),Object(r.b)("p",null,"One of the major selling points of Service Fabric is its ability to make services highly available by monitoring them and restarting them if necessary.  "),Object(r.b)("p",null,"Regardless of whether the service is guest executable or Service Fabric cognizant service, Service Fabric monitors the service to make sure it runs correctly. In our case, the service will crash whenever a ",Object(r.b)("inlineCode",{parentName:"p"},"crash")," command is submitted. So if you crash the service, you will see that Service Fabric detects the failure and reports a bad health on the Service Fabric Explorer:"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/XdY1JHg.png",alt:"Error Deployment"}))),Object(r.b)("p",null,"You will notice that the little web server is no longer available when you try to access it. But if you wait for a few seconds and try again, you will be very happy to know that the web server is available again. This is because Service Fabric detected that the service went down, restarted it and made it available holding to the promise of ",Object(r.b)("inlineCode",{parentName:"p"},"high availability")," or ",Object(r.b)("inlineCode",{parentName:"p"},"self healing"),"."),Object(r.b)("p",null,"However, there is only one little problem! The unhealthy indicators (warning or errors) on the explorer may never go away because there isn't anything that resets them. So the health checks will also be shown once they are reported. This could become a little of a problem if you have an external tool that read health check state. "),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"The above statement is not entirely true! I have seen the latest versions of Service Fabric remove the warning/errors after a little while.")),Object(r.b)("p",null,"In any case, I will show a better way (in my opinion) to deal with this shortly in this post. So read on if you are interested."),Object(r.b)("h2",{id:"cleanup"},"Cleanup"),Object(r.b)("p",null,"In order to remove the named application and its services, you can issue these PowerShell commands:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"# Delete the named service\nRemove-ServiceFabricService -ServiceName $serviceName -Force\n\n# Delete the named application and its named services\nRemove-ServiceFabricApplication -ApplicationName $appName -Force\n")),Object(r.b)("p",null,"In order to delete the application type:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),'# If no named apps are running, you can delete the app type/version\nUnregister-ServiceFabricApplicationType -ApplicationTypeName $appTypeName -ApplicationTypeVersion "1.0.0" -Force\n')),Object(r.b)("h2",{id:"versions--upgrade"},"Versions & Upgrade"),Object(r.b)("p",null,"It turned out that Service Fabric does not really care how you name your versions! If you name your versions as numbers like 1.0.0 or 1.1.0, this naming convention is referred to as ",Object(r.b)("inlineCode",{parentName:"p"},"Semantic Versioning"),". But you are free to use whatever version naming convention you want. "),Object(r.b)("p",null,"Let us use a different version scheme for our simple app. How about alpha, beta and productionV1, productionV2, etc. Let us cleanup our app from the cluster (as shown above), apply some changes to the ",Object(r.b)("inlineCode",{parentName:"p"},"crashable")," service, update the manifest files to make the version ",Object(r.b)("inlineCode",{parentName:"p"},"Beta")," and re-deploy using the beta version:"),Object(r.b)("h3",{id:"the-application-manifest"},"The Application Manifest"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-xml"}),'<?xml version="1.0" encoding="utf-8"?>\n<ApplicationManifest ApplicationTypeName="BasicAvailabilityAppType" \n                     ApplicationTypeVersion="Beta"\n                     xmlns:xsd="http://www.w3.org/2001/XMLSchema" \n                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \n                     xmlns="http://schemas.microsoft.com/2011/01/fabric">\n   <ServiceManifestImport>\n      <ServiceManifestRef ServiceManifestName="CrashableServiceTypePkg" ServiceManifestVersion="Beta" />\n   </ServiceManifestImport>\n</ApplicationManifest>\n')),Object(r.b)("h3",{id:"the-service-manifest"},"The Service Manifest"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-xml"}),'<?xml version="1.0" encoding="utf-8"?>\n<ServiceManifest Name="CrashableServiceTypePkg"\n                 Version="Beta"\n                 xmlns="http://schemas.microsoft.com/2011/01/fabric"\n                 xmlns:xsd="http://www.w3.org/2001/XMLSchema"\n                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n  <ServiceTypes>\n    <StatelessServiceType ServiceTypeName="CrashableServiceType" UseImplicitHost="true" />\n  </ServiceTypes>\n\n  <CodePackage Name="CrashableCodePkg" Version="Beta">\n    <EntryPoint>\n      <ExeHost>\n        <Program>CrashableService.exe</Program>\n        <Arguments>8800</Arguments>\n      </ExeHost>\n    </EntryPoint>\n  </CodePackage>\n\n  \x3c!-- ACL the 8800 port where the crashable service listens --\x3e\n  <Resources>\n    <Endpoints>\n      <Endpoint Name="InputEndpoint" Port="8800" Protocol="http" Type="Input" />\n    </Endpoints>\n  </Resources>\n</ServiceManifest>\n')),Object(r.b)("h3",{id:"deployment-1"},"Deployment"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),'# Define equates (hard-coded):\n$clusterUrl = "localhost"\n$imageStoreConnectionString = "file:C:\\SfDevCluster\\Data\\ImageStoreShare" \n$appPkgName = "BasicAvailabilityAppTypePkg"\n$appTypeName = "BasicAvailabilityAppType"\n$appName = "fabric:/BasicAvailabilityApp"\n$serviceTypeName = "CrashableServiceType"\n$serviceName = $appName + "/CrashableService"\n\n# Connect PowerShell session to a cluster\nConnect-ServiceFabricCluster -ConnectionEndpoint ${clusterUrl}:19000\n\n# Copy the application package to the cluster\nCopy-ServiceFabricApplicationPackage -ApplicationPackagePath "BasicAvailabilityApp" -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Register the application package\'s application type/version\nRegister-ServiceFabricApplicationType -ApplicationPathInImageStore $appPkgName\n\n# After registering the package\'s app type/version, you can remove the package from the cluster image store\nRemove-ServiceFabricApplicationPackage -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Create a named application from the registered app type/version\nNew-ServiceFabricApplication -ApplicationTypeName $appTypeName -ApplicationTypeVersion "Beta" -ApplicationName $appName \n\n# Create a named service within the named app from the service\'s type\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $serviceTypeName -ServiceName $serviceName -Stateless -PartitionSchemeSingleton -InstanceCount 1\n')),Object(r.b)("h3",{id:"upgrade"},"Upgrade"),Object(r.b)("p",null,"Now that the beta version is deployed, let us make another change in the service, change the version to ProdutionV1 (in the application and service manifests) and issue the following PowerShell commands to register and upgrade to ",Object(r.b)("inlineCode",{parentName:"p"},"ProductionV1")),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),'# Copy the application package ProductionV1 to the cluster\nCopy-ServiceFabricApplicationPackage -ApplicationPackagePath "BasicAvailabilityApp-ProductionV1" -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Register the application package\'s application type/version\nRegister-ServiceFabricApplicationType -ApplicationPathInImageStore $appPkgName\n\n# After registering the package\'s app type/version, you can remove the package\nRemove-ServiceFabricApplicationPackage -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Upgrade the application from Beta to ProductionV1\nStart-ServiceFabricApplicationUpgrade -ApplicationName $appName -ApplicationTypeVersion "ProductionV1" -UnmonitoredAuto -UpgradeReplicaSetCheckTimeoutSec 100\n')),Object(r.b)("p",null,"The upgrade takes place using a concept called Upgrade Domains which makes sure that the service that is being upgraded does not ever become unavailable:"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/eSmVVHd.png",alt:"Upgrade Domains"}))),Object(r.b)("p",null,"Once the upgrade is done, the new application and service version is ",Object(r.b)("inlineCode",{parentName:"p"},"ProductionV1"),":"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/l5Ohfgk.png",alt:"Production V1"}))),Object(r.b)("h2",{id:"updates"},"Updates"),Object(r.b)("p",null,"Now that our service is in production, let us see what how we can increase and decrease its number of instances at will. This is very useful to scale the service up and down depending on parameters determined by the operations team. "),Object(r.b)("p",null,"You may have noticed that we have always used instance count 1 when we deployed our named service:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"# Create a named service within the named app from the service's type\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $serviceTypeName -ServiceName $serviceName -Stateless -PartitionSchemeSingleton -InstanceCount 1\n")),Object(r.b)("p",null,"Let us try to increase the instance count to 5 using PowerShell:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"# Dynamically change the named service's number of instances\nUpdate-ServiceFabricService -ServiceName $serviceName -Stateless -InstanceCount 5 -Force\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Please note")," that if your test cluster has less than 5 nodes, you will get health warnings from Service Fabric because SF will not be place more instances than the number of available nodes. This is because SF cannot guarantee availability if it places multiple instances on the same node."),Object(r.b)("p",null,"Anyway, if you get health warning or if you would like to scale back on your service, you can downgrade the number of instances using this PowerShell command:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"Update-ServiceFabricService -ServiceName $serviceName -Stateless -InstanceCount 1 -Force\n")),Object(r.b)("p",null,"Please notice how fast the scaling (up or down) takes place!!"),Object(r.b)("h2",{id:"better-high-availability"},"Better High Availability"),Object(r.b)("p",null,"In a previous section in this post, we deployed the ",Object(r.b)("inlineCode",{parentName:"p"},"crashable")," service and watched it crash when we submitted a ",Object(r.b)("inlineCode",{parentName:"p"},"crash")," command. Service Fabric reported the failure, restarted the service and made it available again. Now we will modify the deployment process to provide a better way to take care of the re-start process. "),Object(r.b)("p",null,"To do so, we will need another service that monitors our ",Object(r.b)("inlineCode",{parentName:"p"},"crashable")," service and reports health checks to Service Fabric. This new code is Service Fabric aware and is demonstrated by Jeff Richter of the Service Fabric team."),Object(r.b)("p",null,"Let us modify the application package to include this new code. Remember our goal is not to change the ",Object(r.b)("inlineCode",{parentName:"p"},"crashable")," service at all. "),Object(r.b)("h3",{id:"the-service-manifest-1"},"The Service Manifest"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-xml"}),'<?xml version="1.0" encoding="utf-8"?>\n<ServiceManifest Name="CrashableServiceTypePkg"\n                 Version="Beta"\n                 xmlns="http://schemas.microsoft.com/2011/01/fabric"\n                 xmlns:xsd="http://www.w3.org/2001/XMLSchema"\n                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n  <ServiceTypes>\n    <StatelessServiceType ServiceTypeName="CrashableServiceType" UseImplicitHost="true" />\n  </ServiceTypes>\n\n  \x3c!-- Code that is NOT Service-Fabric aware --\x3e\n  \x3c!-- Remove Console Redirection in production --\x3e\n  \x3c!-- https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-deploy-existing-app --\x3e\n  <CodePackage Name="CrashableCodePkg" Version="Beta">\n    <EntryPoint>\n      <ExeHost>\n        <Program>CrashableService.exe</Program>\n        <Arguments>8800</Arguments>\n        <ConsoleRedirection FileRetentionCount="5" FileMaxSizeInKb="2048"/>\n      </ExeHost>\n    </EntryPoint>\n  </CodePackage>\n\n  \x3c!-- Code that is Service-Fabric aware --\x3e\n  \x3c!-- Remove Console Redirection in production --\x3e\n  \x3c!-- https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-deploy-existing-app --\x3e\n  <CodePackage Name="MonitorCodePkg" Version="Beta">\n    <EntryPoint>\n      <ExeHost>\n        <Program>MonitorService.exe</Program>\n        <Arguments>8800</Arguments>\n        <ConsoleRedirection FileRetentionCount="5" FileMaxSizeInKb="2048"/>\n      </ExeHost>\n    </EntryPoint>\n  </CodePackage>\n\n  \x3c!-- ACL the 8800 port where the crashable service listens --\x3e\n  <Resources>\n    <Endpoints>\n      <Endpoint Name="InputEndpoint" Port="8800" Protocol="http" Type="Input" />\n    </Endpoints>\n  </Resources>\n</ServiceManifest>\n')),Object(r.b)("p",null,"There are several things here:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Our ",Object(r.b)("inlineCode",{parentName:"li"},"crashable")," service is still the same. It accepts an argumengt to tell it which port number to listen on."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ConsoleRedirection")," is added to allow us to see the console output in the SF log files. This is to be removed in production."),Object(r.b)("li",{parentName:"ul"},"Now there is one service i.e. ",Object(r.b)("inlineCode",{parentName:"li"},"CrashableServiceType")," but two code bases: one for the original exe and another code for the monitor that will monitor our ",Object(r.b)("inlineCode",{parentName:"li"},"crashable")," service. This is really nice as it allows us to add Service Fabric code to an existing service without much of intervention."),Object(r.b)("li",{parentName:"ul"},"The ",Object(r.b)("inlineCode",{parentName:"li"},"Endoints")," must be specified to allow the Service Fabric to ",Object(r.b)("inlineCode",{parentName:"li"},"ACL")," the port that we want opened for our service to listen on. The ",Object(r.b)("inlineCode",{parentName:"li"},"Input")," type instructs SF to accepts input from the Internet.")),Object(r.b)("p",null,"The package folders look like this:"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/fYG5oLe.png",alt:"Advanced Service Dir"}))),Object(r.b)("h3",{id:"the-monitor-service"},"The Monitor Service"),Object(r.b)("p",null,"It is also a console app!! But it includes a Service Fabric Nuget package so it can use the ",Object(r.b)("inlineCode",{parentName:"p"},"FabricClient")," to communicate health checks to the local cluster. Basically, it sets up a timer to check the performance and availability of our ",Object(r.b)("inlineCode",{parentName:"p"},"crashable")," service. It reports to Service Fabric when failures take place. "),Object(r.b)("p",null,"Doing so makes our ",Object(r.b)("inlineCode",{parentName:"p"},"crashable")," service much more resilient to crashes or slow performances as it is monitored by the monitored service and re-started if necessary by Service Fabric. The health checks are also cleared much quicker."),Object(r.b)("h3",{id:"console-outputs-in-the-local-cluster"},"Console Outputs in the local cluster"),Object(r.b)("p",null,"You can use the Service Fabric cluster explorer to find out where Service Fabric stores services on disk. This is available from the Nodes section:"),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/bvXbjc2.png",alt:"SF Cluster Nodes"}))),Object(r.b)("p",null,Object(r.b)("img",Object(i.a)({parentName:"p"},{src:"http://i.imgur.com/lqq6NJ4.png",alt:"Node Disk"}))),Object(r.b)("p",null,"This directory has a ",Object(r.b)("inlineCode",{parentName:"p"},"log")," folder that stores the output of each service. This can be very useful for debug purposes. To use it, however, you must have the ",Object(r.b)("inlineCode",{parentName:"p"},"ConsoleRedirection")," turned on as shown above."),Object(r.b)("h2",{id:"what-is-next"},"What is next?"),Object(r.b)("p",null,"In future posts, I will use Service Fabric .NET programming model to develop and deploy stateless and stateful services to demonstrate Service Fabric fundamental concepts. "))}p.isMDXComponent=!0},138:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return u}));var i=a(0),n=a.n(i);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=n.a.createContext({}),p=function(e){var t=n.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},b=function(e){var t=p(e.components);return n.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},h=n.a.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),b=p(a),h=i,u=b["".concat(c,".").concat(h)]||b[h]||m[h]||r;return a?n.a.createElement(u,o(o({ref:t},l),{},{components:a})):n.a.createElement(u,o({ref:t},l))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,c=new Array(r);c[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,c[1]=o;for(var l=2;l<r;l++)c[l]=a[l];return n.a.createElement.apply(null,c)}return n.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);