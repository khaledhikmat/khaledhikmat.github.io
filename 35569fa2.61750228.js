(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{138:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),p=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),m=a,h=u["".concat(o,".").concat(m)]||u[m]||b[m]||r;return n?i.a.createElement(h,s(s({ref:t},l),{},{components:n})):i.a.createElement(h,s({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},87:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(3),i=n(7),r=(n(0),n(138)),o={title:"Service Fabric Fundamentals",author:"Khaled Hikmat",author_title:"Software Engineer",author_url:"https://github.com/khaledhikmat",author_image_url:"https://avatars1.githubusercontent.com/u/3119726?s=400&u=090899e7b366dd702f9d0d5e483f20089010b25c&v=4",tags:["Service Fabric"]},s={permalink:"/blog/2016/12/15/service-fabric-fundamentals",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/blog/blog/2016-12-15-service-fabric-fundamentals.md",source:"@site/blog/2016-12-15-service-fabric-fundamentals.md",description:"The Service Fabric iOT sample app is a great sample to follow for our own Service Fabric apps. In this post, I used code snippets and concepts from the iOT sample to build a small app to demonstrate some fundamentals concepts that I feel are important.",date:"2016-12-15T00:00:00.000Z",tags:[{label:"Service Fabric",permalink:"/blog/tags/service-fabric"}],title:"Service Fabric Fundamentals",readingTime:19.585,truncated:!1,prevItem:{title:"How to generate a static site using Wyam",permalink:"/blog/2016/12/23/how-to-generate-this-site"},nextItem:{title:"Service Fabric Basics",permalink:"/blog/2016/12/02/service-fabric-basics"}},c=[{value:"The app scenario",id:"the-app-scenario",children:[]},{value:"Source Code",id:"source-code",children:[]},{value:"Fundamental Concepts",id:"fundamental-concepts",children:[{value:"HTTP Endpoints",id:"http-endpoints",children:[]},{value:"HTTP Web APIs",id:"http-web-apis",children:[]},{value:"HTTP vs. RCP Endpoints",id:"http-vs-rcp-endpoints",children:[]},{value:"Reliable Collections",id:"reliable-collections",children:[]},{value:"Partitions, Replicas and Instances",id:"partitions-replicas-and-instances",children:[]},{value:"Result Aggregation",id:"result-aggregation",children:[]},{value:"Multi-Tenancy",id:"multi-tenancy",children:[]},{value:"Configuration",id:"configuration",children:[]}]},{value:"PowerShell Management Scripts",id:"powershell-management-scripts",children:[{value:"Deployment",id:"deployment",children:[]},{value:"Obliterate",id:"obliterate",children:[]},{value:"Update",id:"update",children:[]},{value:"Upgrade",id:"upgrade",children:[]},{value:"Test",id:"test",children:[]}]},{value:"What is next?",id:"what-is-next",children:[]}],l={toc:c};function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Azure-Samples/service-fabric-dotnet-iot"}),"Service Fabric iOT sample app")," is a great sample to follow for our own Service Fabric apps. In this post, I used code snippets and concepts from the iOT sample to build a small app to demonstrate some fundamentals concepts that I feel are important."),Object(r.b)("p",null,"The source code for this post is available ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/khaledhikmat/service-fabric-fundamentals"}),"here"),"."),Object(r.b)("h2",{id:"the-app-scenario"},"The app scenario"),Object(r.b)("p",null,"The app is called Rate Aggregator where we have an app that monitors hotel rate requests coming in from somewhere (presumably from some site) and aggregates the result by city. I also wanted the app to be multi-tenant so we can have an app instance for each rate service provider i.e. Contoso and Fabrican. "),Object(r.b)("p",null,"The app is quite simple and consists of two services: Web Service to act as a front-end and a rates service to actually process the rates and aggregate them:"),Object(r.b)("p",null,Object(r.b)("img",Object(a.a)({parentName:"p"},{src:"http://i.imgur.com/trNQnSS.png",alt:"App Components"}))),Object(r.b)("h2",{id:"source-code"},"Source Code"),Object(r.b)("p",null,"The solution source code consists of 4 different projects:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Common Project - a class library that has the common classes that are shared across the other projects. Please note that this library must be built using the ",Object(r.b)("inlineCode",{parentName:"li"},"x64")," platform."),Object(r.b)("li",{parentName:"ul"},"Web Service - a stateless Service Fabric service created using the Visual Studio ASP.NET Core template."),Object(r.b)("li",{parentName:"ul"},"Rates Service - a stateful Service Fabric service created using the Visual Studio ASP.NET Core template."),Object(r.b)("li",{parentName:"ul"},"An app project to contain the Service Fabric instances and provide application manifests."),Object(r.b)("li",{parentName:"ul"},"A collection of PowerShell scripts that manage the deployment, un-deployment, update, upgrade and test. We will go through those files in this post.")),Object(r.b)("p",null,"Please note:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"I created the solution using VS 2015 Service Fabric template. But actually the projects are regular projects that include Service Fabric NuGet packages. The only project that is quite specific to Service Fabric is the app project i.e. ",Object(r.b)("inlineCode",{parentName:"li"},"RateAggregatorApp")," ...but as demonstrated in a ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"/blog/2016/12/02/service-fabric-basics"}),"previous post"),", the app manifests and packaging can be easily generated manually."),Object(r.b)("li",{parentName:"ul"},"The ASP.NET Code template in Service Fabric is still in preview. I noticed some odd stuff about it:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"The template assumes that you are building stateless services! To create Stateful services using the ASP.NET template, manual intervention have to take place which I will note in this post"),Object(r.b)("li",{parentName:"ul"},"The useful ",Object(r.b)("inlineCode",{parentName:"li"},"ServiceEventSource.cs")," class is not included in the generated project. So if you want to use ETW logging, you must create this file manually (copy it from another SF project)"),Object(r.b)("li",{parentName:"ul"},"The template includes, in the ",Object(r.b)("inlineCode",{parentName:"li"},"Program.cs")," file the Service Fabric registration code and the Service class. It is useful to break up apart and create a class (using the name of the service) to describe the service i.e. ",Object(r.b)("inlineCode",{parentName:"li"},"WebService")," and ",Object(r.b)("inlineCode",{parentName:"li"},"RatesService")))),Object(r.b)("li",{parentName:"ul"},"The Service Fabric ",Object(r.b)("inlineCode",{parentName:"li"},"RateAggregatorApp")," ",Object(r.b)("inlineCode",{parentName:"li"},"APplicationManifest.xml")," file has a section for ",Object(r.b)("inlineCode",{parentName:"li"},"DefaultServices")," which automatically deploys the default services whenever an app is deployed. I usually remove the default services from the manifest file so i can better control the named app instance and service creation process (which I will demo in this post).")),Object(r.b)("h2",{id:"fundamental-concepts"},"Fundamental Concepts"),Object(r.b)("p",null,"The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Azure-Samples/service-fabric-dotnet-iot"}),"iOT")," sample includes really nice code utilities that can be used to build ",Object(r.b)("inlineCode",{parentName:"p"},"Uri"),"s for services especially when the service exposes HTTP endpoints. The most important concepts that I would like to convey are:"),Object(r.b)("h3",{id:"http-endpoints"},"HTTP Endpoints"),Object(r.b)("p",null,"If you would like to expose HTTP Endpoints for your service, Microsoft strongly recommends that you build the URL as follows:"),Object(r.b)("p",null,Object(r.b)("img",Object(a.a)({parentName:"p"},{src:"http://i.imgur.com/qQdvX9h.png",alt:"HTTP Endpoint URL"}))),Object(r.b)("p",null,"Examples:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"Http://localhost:8084/ContosoRateAggregatorApp/7217642a-2ac8-4b29-b52d-3e92303ce1b2/131262989332452689/f74f07f7-d92f-47b9-8d6b-c86966c78d09")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"Http://localhost:8084/FabricanRateAggregatorApp/13049e47-9727-4e02-9086-8fd6e2457313/131262989924122573/3b3455d8-487e-4ec4-9bd8-64ba8e658662"))),Object(r.b)("p",null,"For stateful services, this makes total sense! The combination of ",Object(r.b)("inlineCode",{parentName:"p"},"partitionId")," and ",Object(r.b)("inlineCode",{parentName:"p"},"instanceId")," are great for diagnostics and the ",Object(r.b)("inlineCode",{parentName:"p"},"guid")," makes every endpoint unique which is really useful because services are sometimes moved around. However, for Stateless services, I think we can easily omit the ",Object(r.b)("inlineCode",{parentName:"p"},"partitionId"),", the ",Object(r.b)("inlineCode",{parentName:"p"},"instanceId")," and the ",Object(r.b)("inlineCode",{parentName:"p"},"guid")," since stateless service endpoints are usually load balanced as they accept traffic from the Internet. Examples of stateless services endpoints:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"Http://localhost:8082/FabricanRateAggregatorApp")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"Http://localhost:8082/ContosoRateAggregatorApp"))),Object(r.b)("p",null,"If you are planning to expose multiple stateless web services in each app instances, then perhaps adding the service name to the end of the URL would make sense.Examples:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"Http://localhost:8082/FabricanRateAggregatorApp/WebService")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"Http://localhost:8082/ContosoRateAggregatorApp/WebService"))),Object(r.b)("p",null,"The demo app source code common project includes a ",Object(r.b)("inlineCode",{parentName:"p"},"WebHostCommunicationListener")," class (which is borrowed from the iOT sample) shows a really good implementation of how to manage this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'string ip = this.serviceContext.NodeContext.IPAddressOrFQDN;\nEndpointResourceDescription serviceEndpoint = this.serviceContext.CodePackageActivationContext.GetEndpoint(this.endpointName);\nEndpointProtocol protocol = serviceEndpoint.Protocol;\nint port = serviceEndpoint.Port;\nstring host = "+";\n\nstring listenUrl;\nstring path = this.appPath != null ? this.appPath.TrimEnd(\'/\') + "/" : "";\n\nif (this.serviceContext is StatefulServiceContext)\n{\n    StatefulServiceContext statefulContext = this.serviceContext as StatefulServiceContext;\n    listenUrl = $"{serviceEndpoint.Protocol}://{host}:{serviceEndpoint.Port}/{path}{statefulContext.PartitionId}/{statefulContext.ReplicaId}/{Guid.NewGuid()}";\n}\nelse\n{\n    listenUrl = $"{serviceEndpoint.Protocol}://{host}:{serviceEndpoint.Port}/{path}";\n}\n\nthis.webHost = this.build(listenUrl);\nthis.webHost.Start();\n\nreturn Task.FromResult(listenUrl.Replace("://+", "://" + ip));\n')),Object(r.b)("h3",{id:"http-web-apis"},"HTTP Web APIs"),Object(r.b)("p",null,"Using ASP.NET Core to implement the Stateless and Stateful services has the distinct advantage of allowing the services expose a Web API layer that can be used by clients to call on the services. The Web API layer has regular controllers with normal Web API decoration to allow the services be called from regular HTTP clients:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'    [Route("api/[controller]")]\n    public class RatesController : Controller\n    {\n        private readonly IReliableStateManager stateManager;\n        private readonly StatefulServiceContext context;\n        private readonly CancellationTokenSource serviceCancellationSource;\n\n        public RatesController(IReliableStateManager stateManager, StatefulServiceContext context, CancellationTokenSource serviceCancellationSource)\n        {\n            this.stateManager = stateManager;\n            this.context = context;\n            this.serviceCancellationSource = serviceCancellationSource;\n        }\n\n        [HttpGet]\n        [Route("queue/length")]\n        public async Task<IActionResult> GetQueueLengthAsync()\n        {\n            ....\n        }\n    }\n')),Object(r.b)("p",null,"Please note that the service has the ",Object(r.b)("inlineCode",{parentName:"p"},"IReliableStateManager"),", the ",Object(r.b)("inlineCode",{parentName:"p"},"StatefulServiceContext")," and the ",Object(r.b)("inlineCode",{parentName:"p"},"CancellationSource")," injected. This allows the Web API controller to use the service reliable collections and anything else related to service context. For example, this is the implementation of the queue length Web API method:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'        [HttpGet]\n        [Route("queue/length")]\n        public async Task<IActionResult> GetQueueLengthAsync()\n        {\n            IReliableQueue<RateRequest> queue = await this.stateManager.GetOrAddAsync<IReliableQueue<RateRequest>>(RatesService.RateQueueName);\n\n            using (ITransaction tx = this.stateManager.CreateTransaction())\n            {\n                long count = await queue.GetCountAsync(tx);\n\n                return this.Ok(count);\n            }\n        }\n')),Object(r.b)("p",null,"Note how the API controller uses the injected ",Object(r.b)("inlineCode",{parentName:"p"},"StateManager")," to gain access to the reliable queue and reports on its length."),Object(r.b)("p",null,"Since the service interface is implemented as regular Web API controllers (or controllers), they can also be exposed as ",Object(r.b)("inlineCode",{parentName:"p"},"Swagger")," and allow other an API management layer to front-end these services.  "),Object(r.b)("p",null,"To make this possible, the service must override the ",Object(r.b)("inlineCode",{parentName:"p"},"CreateServiceInstanceListeners")," in case of stateless services and ",Object(r.b)("inlineCode",{parentName:"p"},"CreateServiceReplicaListeners")," in case of stateful services. Here is an example of the Stateful service:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\n{\n    return new ServiceReplicaListener[1]\n    {\n        new ServiceReplicaListener(\n            context =>\n            {\n                string tenantName = new Uri(context.CodePackageActivationContext.ApplicationName).Segments.Last();\n\n                return new WebHostCommunicationListener(\n                    context,\n                    tenantName,\n                    "ServiceEndpoint",\n                    uri =>\n                    {\n                        ServiceEventSource.Current.Message($"Listening on {uri}");\n\n                        return new WebHostBuilder().UseWebListener()\n                            .ConfigureServices(\n                                services => services\n                                    .AddSingleton<StatefulServiceContext>(this.Context)\n                                    .AddSingleton<IReliableStateManager>(this.StateManager)\n                                    .AddSingleton<CancellationTokenSource>(this._webApiCancellationSource))\n                            .UseContentRoot(Directory.GetCurrentDirectory())\n                            .UseStartup<Startup>()\n                            .UseUrls(uri)\n                            .Build();\n                    });\n            })\n    };\n}\n\n')),Object(r.b)("p",null,"Please note the use of the ",Object(r.b)("inlineCode",{parentName:"p"},"WebHostCommunicationListener")," and how we inject the service context, state manager and the cancellation token."),Object(r.b)("p",null,"In our demo app, both statelss and stateful services implement their interface as Web API."),Object(r.b)("h3",{id:"http-vs-rcp-endpoints"},"HTTP vs. RCP Endpoints"),Object(r.b)("p",null,"Instead of HTTP Web API, Services (especially stateful) can expose an interface using a built-in RCP communicaton listener. In this case, the service implements an interface and make it easy for clients to call upon the service using the interface. For example, a stateful service might have an interface that looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"    public interface ILookupService : IService\n    {\n        Task EnqueueEvent(SalesEvent sEvent);\n        Task<string> GetNodeName();\n        Task<int> GetEventsCounter(CancellationToken ct);\n    }\n")),Object(r.b)("p",null,"The service will then be implemented this way:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"    internal sealed class LookupService : StatefulService, ILookupService\n    {\n    ...\n    }\n")),Object(r.b)("p",null,"The service will override the CreateServiceReplicaListeners as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'    protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\n    {\n        return new[]\n            {\n                new ServiceReplicaListener(context =>\n                    this.CreateServiceRemotingListener(context),\n                    "rpcPrimaryEndpoint",\n                    false)\n            };\n    }\n')),Object(r.b)("p",null,"Although this looks nice and complies with Object Oriented programming, I think it should only be used with internal stateful services (those that do not expose an outside interface). Stateless services that are used by external clients are better off using an HTTP Web API interface which makes them easily consumable by many clients in different languages. "),Object(r.b)("h3",{id:"reliable-collections"},"Reliable Collections"),Object(r.b)("p",null,"Since we have the state manager injected in the stateful service Web API controllers, it makes all the service reliable collections available to the Web API controllers. In our demo, the ",Object(r.b)("inlineCode",{parentName:"p"},"RatesService")," Web API controller i.e. ",Object(r.b)("inlineCode",{parentName:"p"},"RatesController")," uses the reliable queue to get the queue length and enqueue rate requests to the service. The service processes the incoming ",Object(r.b)("inlineCode",{parentName:"p"},"RateRequest")," in its ",Object(r.b)("inlineCode",{parentName:"p"},"RunAsyc")," method and aggregates the results in a reliable dictionary indexed by city/country:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'protected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    cancellationToken.Register(() => this._webApiCancellationSource.Cancel());\n\n    IReliableDictionary<string, RateAggregation> citiesDictionary = await this.StateManager.GetOrAddAsync<IReliableDictionary<string, RateAggregation>>(RateCitiesDictionaryName);\n    IReliableQueue<RateRequest> queue = await this.StateManager.GetOrAddAsync<IReliableQueue<RateRequest>>(RateQueueName);\n\n    while (true)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n\n        try\n        {\n            using (var tx = this.StateManager.CreateTransaction())\n            {\n                var result = await queue.TryDequeueAsync(tx);\n\n                if (result.HasValue)\n                {\n                    RateRequest request = result.Value;\n\n                    // TODO: Process the request\n                    // TODO: Go against the reservation provider to pick up the rate\n                    // TODO: How do I determine the reservation provider per tenant?\n                    int nights = (request.CheckOutDate - request.CheckInDate).Days;\n                    int netAmount = _random.Next(500) * nights;\n                    var newAggregation = new RateAggregation();\n                    newAggregation.Transactions = 1;\n                    newAggregation.Nights = nights;\n                    newAggregation.Amount = (double) netAmount;\n\n                    await citiesDictionary.AddOrUpdateAsync(tx, $"{request.City}/{request.Country}", newAggregation, (key, currentValue) =>\n                    {\n                        currentValue.Transactions += newAggregation.Transactions;\n                        currentValue.Nights += newAggregation.Nights;\n                        currentValue.Amount += newAggregation.Amount;\n                        return currentValue;\n                    });\n\n                    // This commits the add to dictionary and the dequeue operation.\n                    await tx.CommitAsync();\n                }\n            }\n        }\n        catch (Exception e)\n        {\n\n        }\n\n        await Task.Delay(TimeSpan.FromMilliseconds(500), cancellationToken);\n    }\n}\n')),Object(r.b)("p",null,"The reliable dictionary is then used in the service contrloller to return the aggregated result in an API call. "),Object(r.b)("h3",{id:"partitions-replicas-and-instances"},"Partitions, Replicas and Instances"),Object(r.b)("p",null,"In our demo app, we use partitions in the Stateful service i.e. ",Object(r.b)("inlineCode",{parentName:"p"},"RatesService")," to partition our data in 4 different buckets: "),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Rate Requests for the United States"),Object(r.b)("li",{parentName:"ol"},"Rate Requests for Canada"),Object(r.b)("li",{parentName:"ol"},"Rate Requests for Australia"),Object(r.b)("li",{parentName:"ol"},"Rate Requests for other countries")),Object(r.b)("p",null,"Hence our partition key range is 0 (Low Key) to 3 (High Key). We use a very simple method to select the appropriate partition based on the request's country code:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'private long GetPartitionKey(RateRequest request)\n{\n    if (request.Country == "USA")\n        return 0;\n    else if (request.Country == "CAN")\n        return 1;\n    else if (request.Country == "AUS")\n        return 2;\n    else // all others\n        return 3;\n}\n')),Object(r.b)("p",null,"To allow for high availability, Service Fabric uses replicas for stateful services and instances for stateless services. In Service Fabric literature, the term replicas and instances are often exchanged. "),Object(r.b)("p",null,"In order to guarantee high availability of stateful service state, the state for each partition is usually replicated. The number of replicas is decided at the time of deploying the service (as we will see soon in the PowerShell script). This means that, if a stateful service has 4 partitions and the target replica count is 3, for example, then there are 12 instances of that service in Service Fabric.    "),Object(r.b)("p",null,"In order to guarantee high availability of stateless services, Service Fabric allows the instantiation of multiple instances. Usually the number of instances matches the number of nodes in the Service Fabric cluster which allows Service Fabric to distribute an instance on each node. The load balancer then distribute the load across all nodes. "),Object(r.b)("p",null,"Please note, however, that, unlike stateless service instances, a stateful service partitions cannot be changed at run-time once the service is deployed. The number of partitions must be decided initially before the service is deployed to the cluster. Of course, if the service state can be discarded, then of course changes to the partition are allowed. Stateless services number of instances can be updated at any time (up or down) at any time. In fact, this is one of the great features of Service Fabric."),Object(r.b)("h3",{id:"result-aggregation"},"Result Aggregation"),Object(r.b)("p",null,"Since the state is partitioned, does this mean that we have the reliable collections (i.e. queues and dictionaries) scattered among the different partitions? The answer is yes! For example, in order to get the queue length of a stateful service, the client has to query all partitions and ask each service instance about the queue length and add them together to determine the overall queue length for the stateful service:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'[HttpGet]\n[Route("queue/length")]\npublic async Task<IActionResult> GetQueueLengthAsync()\n{\n    ServiceUriBuilder uriBuilder = new ServiceUriBuilder(RatesServiceName);\n    Uri serviceUri = uriBuilder.Build();\n\n    // service may be partitioned.\n    // this will aggregate the queue lengths from each partition\n    ServicePartitionList partitions = await this.fabricClient.QueryManager.GetPartitionListAsync(serviceUri);\n\n    HttpClient httpClient = new HttpClient(new HttpServiceClientHandler());\n\n    long count = 0;\n    foreach (Partition partition in partitions)\n    {\n        Uri getUrl = new HttpServiceUriBuilder()\n            .SetServiceName(serviceUri)\n            .SetPartitionKey(((Int64RangePartitionInformation)partition.PartitionInformation).LowKey)\n            .SetServicePathAndQuery($"/api/rates/queue/length")\n            .Build();\n\n        HttpResponseMessage response = await httpClient.GetAsync(getUrl, this.cancellationSource.Token);\n\n        if (response.StatusCode != System.Net.HttpStatusCode.OK)\n        {\n            return this.StatusCode((int)response.StatusCode);\n        }\n\n        string result = await response.Content.ReadAsStringAsync();\n\n        count += Int64.Parse(result);\n    }\n\n    return this.Ok(count);\n}\n')),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"FabricClient")," is the .NET client used to provide all sorts of management capabilities. It is injected in the Web Service controller to allow them to communicate with each partitition replica and get the needed results as shown above. Then the Web Service adds the count of each partition and return the total lenth of all partitions queues. "),Object(r.b)("p",null,"Similarly, the Web Service uses the ",Object(r.b)("inlineCode",{parentName:"p"},"FabricClient")," to communicate with the each partition replica to get and aggregate the result of each country cities:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'[HttpGet]\n[Route("cities")]\npublic async Task<IActionResult> GetCitiesAsync()\n{\n    ServiceUriBuilder uriBuilder = new ServiceUriBuilder(RatesServiceName);\n    Uri serviceUri = uriBuilder.Build();\n\n    // service may be partitioned.\n    // this will aggregate cities from all partitions\n    ServicePartitionList partitions = await this.fabricClient.QueryManager.GetPartitionListAsync(serviceUri);\n\n    HttpClient httpClient = new HttpClient(new HttpServiceClientHandler());\n\n    List<CityStats> cities = new List<CityStats>();\n    foreach (Partition partition in partitions)\n    {\n        Uri getUrl = new HttpServiceUriBuilder()\n            .SetServiceName(serviceUri)\n            .SetPartitionKey(((Int64RangePartitionInformation)partition.PartitionInformation).LowKey)\n            .SetServicePathAndQuery($"/api/rates/cities")\n            .Build();\n\n        HttpResponseMessage response = await httpClient.GetAsync(getUrl, this.cancellationSource.Token);\n\n        if (response.StatusCode != System.Net.HttpStatusCode.OK)\n        {\n            return this.StatusCode((int)response.StatusCode);\n        }\n\n        JsonSerializer serializer = new JsonSerializer();\n        using (StreamReader streamReader = new StreamReader(await response.Content.ReadAsStreamAsync()))\n        {\n            using (JsonTextReader jsonReader = new JsonTextReader(streamReader))\n            {\n                List<CityStats> result = serializer.Deserialize<List<CityStats>>(jsonReader);\n\n                if (result != null)\n                {\n                    cities.AddRange(result);\n                }\n            }\n        }\n    }\n\n    return this.Ok(cities);\n}\n\n')),Object(r.b)("h3",{id:"multi-tenancy"},"Multi-Tenancy"),Object(r.b)("p",null,"One of the great features of Service Fabric is its ability to allow the creation of multi-tenant scanarios. In our demo case, we may launch an app for Contoso rates and another one for Fabrican rates. We want these two apps to be of the same type but they should be completely isolated of each other. So we create two named app instances: ",Object(r.b)("inlineCode",{parentName:"p"},"ConosoRateAggretor")," and ",Object(r.b)("inlineCode",{parentName:"p"},"FabricanRateAggregator"),". This means that we have different set of services for each app operated independely and perhaps scaled, updated and upgraded independently."),Object(r.b)("p",null,Object(r.b)("img",Object(a.a)({parentName:"p"},{src:"http://i.imgur.com/e6YmFNy.png",alt:"Named App Instances"}))," "),Object(r.b)("p",null,"This is really useful in many scenarios and allows for many great advantages. In the next section, we will see how easy it is to actually deploy, un-deploy, update and upgrade these named instances."),Object(r.b)("h3",{id:"configuration"},"Configuration"),Object(r.b)("p",null,"Given that we have multiple named app instances, how do we pass different parameters for each named instance? In the ",Object(r.b)("inlineCode",{parentName:"p"},"RatesService"),", we would like to have the name of the provider (and probably other configuration items) so we can communicate with the provider to pull rates. In our demo app, we are not actually communicating with the provider."),Object(r.b)("p",null,"To do this, we define parameters for the ",Object(r.b)("inlineCode",{parentName:"p"},"RatesService")," in the Service Settings file as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'<?xml version="1.0" encoding="utf-8" ?>\n<Settings xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.microsoft.com/2011/01/fabric">\n  \x3c!-- Add your custom configuration sections and parameters here --\x3e\n  <Section Name="ParametersSection">\n    <Parameter Name="ProviderName" Value="" />\n  </Section>\n</Settings>\n')),Object(r.b)("p",null,"The section name can be anything. In our case, it is ",Object(r.b)("inlineCode",{parentName:"p"},"ParametersSection"),". To be able to override this value for a specific application instance, we create a ",Object(r.b)("inlineCode",{parentName:"p"},"ConfigOverride")," when we import the service manifest in the application manifest:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'<ServiceManifestImport>\n<ServiceManifestRef ServiceManifestName="RatesServicePkg" ServiceManifestVersion="1.0.0" />\n<ConfigOverrides>\n  <ConfigOverride Name="Config">\n    <Settings>\n      <Section Name="ParametersSection">\n        <Parameter Name="ProviderName" Value="[RatesService_ProviderName]" />\n      </Section>\n    </Settings>\n  </ConfigOverride>\n</ConfigOverrides>\n</ServiceManifestImport>\n')),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"The convention is to name the value as ",Object(r.b)("inlineCode",{parentName:"em"},"ServiceName_ParameterName"))),Object(r.b)("p",null,"Finally, we must adjust the application manifest to include the required parameter:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'<ApplicationManifest xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ApplicationTypeName="RateAggregatorAppType" ApplicationTypeVersion="1.0.0" xmlns="http://schemas.microsoft.com/2011/01/fabric">\n  <Parameters>\n    <Parameter Name="RatesService_ProviderName" DefaultValue="" />\n  </Parameters>\n  ...\n</ApplicationManifest>\n')),Object(r.b)("p",null,"Finally, at the deployment time (as you will see in more detail in the deployment script), we will specify a PowerShell ",Object(r.b)("inlineCode",{parentName:"p"},"Hashtable")," to override these parameters per named instance:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'New-ServiceFabricApplication -ApplicationTypeName $appTypeName -ApplicationTypeVersion $version -ApplicationName $appName -ApplicationParameter @{"RatesService_ProviderName" = "Contoso"}  \n\nNew-ServiceFabricApplication -ApplicationTypeName $appTypeName -ApplicationTypeVersion $version -ApplicationName $appName -ApplicationParameter @{"RatesService_ProviderName" = "Fabrican"}  \n')),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"RatesService")," code will then make sure of this parameter to contact the instance-bound provider."),Object(r.b)("h2",{id:"powershell-management-scripts"},"PowerShell Management Scripts"),Object(r.b)("h3",{id:"deployment"},"Deployment"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"This PowerShell script assumes that you used Visual Studio to generate the Service Fabric app package info (right-click the Service Fabric App and select ",Object(r.b)("inlineCode",{parentName:"strong"},"Package"),") or you built the app package manually as demonstrated in a previous ",Object(r.b)("a",Object(a.a)({parentName:"strong"},{href:"/blog/2016/12/02/service-fabric-basics"}),"post"),". The created package directory is expected to have the following format ",Object(r.b)("inlineCode",{parentName:"strong"},"v1.0.0")," where 1.0.0 is the version number")),Object(r.b)("p",null,"This PowerShell script copies the package to the cluster, registers the app type and creates two name app instances (i.e. Contoso and Fabrican). In each app instance, create two services: Web Service as a front-end and Rates service as a back-end. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'$clusterUrl = "localhost"\n$imageStoreConnectionString = "file:C:\\SfDevCluster\\Data\\ImageStoreShare"   # Use this with OneBox\nIf ($clusterUrl -ne "localhost")\n{\n    $imageStoreConnectionString = "fabric:ImageStore"                       # Use this when not using OneBox\n}\n\n# Used only for the inmage store....it can be any name!!!\n$appPkgName = "RateAggregatorAppTypePkg"\n\n# Define the app and service types\n$appTypeName = "RateAggregatorAppType"\n$webServiceTypeName = "WebServiceType"\n$ratesServiceTypeName = "RatesServiceType"\n\n# Define the version\n$version = "1.0.0"\n\n# Connect PowerShell session to a cluster\nConnect-ServiceFabricCluster -ConnectionEndpoint ${clusterUrl}:19000\n\n# Copy the application package to the cluster\nCopy-ServiceFabricApplicationPackage -ApplicationPackagePath "RateAggregatorApp\\pkg\\v$version" -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Register the application package\'s application type/version\nRegister-ServiceFabricApplicationType -ApplicationPathInImageStore $appPkgName\n\n# After registering the package\'s app type/version, you can remove the package\nRemove-ServiceFabricApplicationPackage -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Deploy the first aplication name (i.e. Contoso)\n$appName = "fabric:/ContosoRateAggregatorApp"\n$webServiceName = $appName + "/WebService"\n$ratesServiceName = $appName + "/RatesService"\n\n# Create a named application from the registered app type/version\nNew-ServiceFabricApplication -ApplicationTypeName $appTypeName -ApplicationTypeVersion $version -ApplicationName $appName -ApplicationParameter @{"RatesService_ProviderName" = "Contoso"}  \n\n# Create a named service within the named app from the service\'s type\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $webServiceTypeName -ServiceName $webServiceName -Stateless -PartitionSchemeSingleton -InstanceCount 1\n\n# Create a named service within the named app from the service\'s type\n# For stateful services, it is important to indicate in the service manifest that the service is stateful and that it has a persisted state:\n# <StatefulServiceType ServiceTypeName="RatesServiceType" HasPersistedState="true"/>\n# Actually all of these switches are important on the PowerShell command:\n# -PartitionSchemeUniformInt64 $true -PartitionCount 4 -MinReplicaSetSize 2 -TargetReplicaSetSize 3 -LowKey 0 -HighKey 3 -HasPersistedState\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $ratesServiceTypeName -ServiceName $ratesServiceName -PartitionSchemeUniformInt64 $true -PartitionCount 4 -MinReplicaSetSize 2 -TargetReplicaSetSize 3 -LowKey 0 -HighKey 3 -HasPersistedState\n\n# Deploy the second aplication name (i.e. Fabrican)\n$appName = "fabric:/FabricanRateAggregatorApp"\n$webServiceName = $appName + "/WebService"\n$ratesServiceName = $appName + "/RatesService"\n\n# Create a named application from the registered app type/version\nNew-ServiceFabricApplication -ApplicationTypeName $appTypeName -ApplicationTypeVersion $version -ApplicationName $appName -ApplicationParameter @{"RatesService_ProviderName" = "Fabrican"}  \n\n# Create a named service within the named app from the service\'s type\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $webServiceTypeName -ServiceName $webServiceName -Stateless -PartitionSchemeSingleton -InstanceCount 1\n\n# Create a named service within the named app from the service\'s type\nNew-ServiceFabricService -ApplicationName $appName -ServiceTypeName $ratesServiceTypeName -ServiceName $ratesServiceName -PartitionSchemeUniformInt64 $true -PartitionCount 4 -MinReplicaSetSize 2 -TargetReplicaSetSize 3 -LowKey 0 -HighKey 3 -HasPersistedState\n')),Object(r.b)("h3",{id:"obliterate"},"Obliterate"),Object(r.b)("p",null,"This PowerShell script removes all application name instances and their services from the selected cluster. It does this based on the application type."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'$clusterUrl = "localhost"\n\n# Define the app and service types\n$applicationTypes = "RateAggregatorAppType"\n\n# Connect PowerShell session to a cluster\nConnect-ServiceFabricCluster -ConnectionEndpoint ${clusterUrl}:19000\n\n# Remove all application names instances and their services\nGet-ServiceFabricApplication | Where-Object { $applicationTypes -contains $_.ApplicationTypeName } | Remove-ServiceFabricApplication -Force\nGet-ServiceFabricApplicationType | Where-Object { $applicationTypes -contains $_.ApplicationTypeName } | Unregister-ServiceFabricApplicationType -Force\n\n')),Object(r.b)("h3",{id:"update"},"Update"),Object(r.b)("p",null,"This PowerShell script updates the web service in each app named instance to have 5 instances. Please note that this works if the number of instances does  not exceed the number of nodes in the cluster."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'$clusterUrl = "localhost"\n\n# Deploy the first aplication name (i.e. Contoso)\n$appName = "fabric:/ContosoRateAggregatorApp"\n$webServiceName = $appName + "/WebService"\n\n# Dynamically change the named service\'s number of instances (the cluster must have at least 5 nodes)\nUpdate-ServiceFabricService -ServiceName $webServiceName -Stateless -InstanceCount 5 -Force\n\n# Deploy the first aplication name (i.e. Fabrican)\n$appName = "fabric:/FabricanRateAggregatorApp"\n$webServiceName = $appName + "/WebService"\n\n# Dynamically change the named service\'s number of instances (the cluster must have at least 5 nodes) \nUpdate-ServiceFabricService -ServiceName $webServiceName -Stateless -InstanceCount 5 -Force\n')),Object(r.b)("h3",{id:"upgrade"},"Upgrade"),Object(r.b)("p",null,"This PowerShell script upgrades the application named instances to a higher version i.e. 1.1.0. As noted earlier, this assumes that you have a new folder named v1.1.0 which contains the upgraded application package. The script uses ",Object(r.b)("inlineCode",{parentName:"p"},"monitored")," upgrade modes and performs the upgrade using upgrade domains. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'$clusterUrl = "localhost"\n$imageStoreConnectionString = "file:C:\\SfDevCluster\\Data\\ImageStoreShare"   # Use this with OneBox\nIf ($clusterUrl -ne "localhost")\n{\n    $imageStoreConnectionString = "fabric:ImageStore"                       # Use this when not using OneBox\n}\n\n# Used only for the inmage store....it can be any name!!!\n$appPkgName = "RateAggregatorAppTypePkg"\n\n# Define the new version\n$version = "1.1.0"\n\n# Connect PowerShell session to a cluster\nConnect-ServiceFabricCluster -ConnectionEndpoint ${clusterUrl}:19000\n\n# Copy the application package to the cluster\nCopy-ServiceFabricApplicationPackage -ApplicationPackagePath "RateAggregatorApp\\pkg\\v$version" -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Register the application package\'s application type/version\nRegister-ServiceFabricApplicationType -ApplicationPathInImageStore $appPkgName\n\n# After registering the package\'s app type/version, you can remove the package\nRemove-ServiceFabricApplicationPackage -ImageStoreConnectionString $imageStoreConnectionString -ApplicationPackagePathInImageStore $appPkgName\n\n# Upgrade the first aplication name (i.e. Contoso)\n$appName = "fabric:/ContosoRateAggregatorApp"\n\n# Upgrade the application to the new version\nStart-ServiceFabricApplicationUpgrade -ApplicationName $appName -ApplicationTypeVersion $version -Monitored -UpgradeReplicaSetCheckTimeoutSec 100\n\n# Upgrade the second aplication name (i.e. Fabrican)\n$appName = "fabric:/FabricanRateAggregatorApp"\n\n# Upgrade the application to the new version\nStart-ServiceFabricApplicationUpgrade -ApplicationName $appName -ApplicationTypeVersion $version -Monitored -UpgradeReplicaSetCheckTimeoutSec 100\n\n')),Object(r.b)("h3",{id:"test"},"Test"),Object(r.b)("p",null,"This PowerShell scripts defines functions to exercise the Service Fabric Web service APIs for each named application instance."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'Function Generate-RateRequests($appName = \'Contoso\', $iterations = 20)\n{\n    Try {\n        Write-Host "Generating $iterations random rate requests against $appName ...." -ForegroundColor Green\n\n        $url = "Http://localhost:8082/$appName" + "RateAggregatorApp/api/requests"\n\n        foreach($i in 1..$iterations)\n        {\n            $checkInDate = get-date -Year (get-random -minimum 2012 -maximum 2016) -Month (get-random -minimum 1 -maximum 12) -Day (get-random -minimum 1 -maximum 28)\n            $nights = get-random -minimum 1 -maximum 30\n            $checkOutDate = $checkInDate.AddDays($nights)\n            $hotelId = get-random -input "1", "2", "3" -count 1\n            $body = @{\n                CheckInDate = get-date $checkInDate -Format "yyy-MM-ddTHH:mm:ss";\n                CheckOutDate = get-date $checkOutDate -Format "yyy-MM-ddTHH:mm:ss";\n                HotelId = $hotelId;\n                HotelName = "Hotel$hotelId";\n                City = "City$hotelId";\n                Country = get-random -input "USA", "USA", "USA", "CAN", "CAN", "CAN", "AUS", "AUS", "AUS", "FRA", "GER", "UAE" -count 1\n            }\n            Write-Host "This is the JSON we are generating for iteration # $i...." -ForegroundColor yellow\n            $json = ConvertTo-Json $body -Depth 3\n            $json\n\n            $result = Invoke-RestMethod -Uri $url -Headers @{"Content-Type"="application/json" } -Body $json -Method POST -TimeoutSec 600\n        }        \n    } Catch {\n        Write-Host "Failure message: $_.Exception.Message" -ForegroundColor red\n        Write-Host "Failure stack trace: $_.Exception.StackTrace" -ForegroundColor red\n        Write-Host "Failure inner exception: $_.Exception.InnerException" -ForegroundColor red\n    }\n}\n\nFunction View-QueueLength($appName = \'Contoso\')\n{\n    Try {\n        Write-Host "View Queue Length for $appName...." -ForegroundColor Green\n\n        $url = "Http://localhost:8082/$appName" + "RateAggregatorApp/api/stats/queue/length"\n        $result = Invoke-RestMethod -Uri $url -Headers @{"Content-Type"="application/json" } -Method GET -TimeoutSec 600\n        $json = ConvertTo-Json $result -Depth 3\n        $json\n    } Catch {\n        Write-Host "Failure message: $_.Exception.Message" -ForegroundColor red\n        Write-Host "Failure stack trace: $_.Exception.StackTrace" -ForegroundColor red\n        Write-Host "Failure inner exception: $_.Exception.InnerException" -ForegroundColor red\n    }\n}\n\nFunction View-Cities($appName = \'Contoso\')\n{\n    Try {\n        Write-Host "View cities for $appName...." -ForegroundColor Green\n\n        $url = "Http://localhost:8082/$appName" + "RateAggregatorApp/api/stats/cities"\n        $result = Invoke-RestMethod -Uri $url -Headers @{"Content-Type"="application/json" } -Method GET -TimeoutSec 600\n        $json = ConvertTo-Json $result -Depth 3\n        $json\n    } Catch {\n        Write-Host "Failure message: $_.Exception.Message" -ForegroundColor red\n        Write-Host "Failure stack trace: $_.Exception.StackTrace" -ForegroundColor red\n        Write-Host "Failure inner exception: $_.Exception.InnerException" -ForegroundColor red\n    }\n}\n\nGenerate-RateRequests -appName Contoso -iterations 100\nGenerate-RateRequests -appName Fabrican -iterations 100\n\nView-QueueLength -appName Contoso\nView-QueueLength -appName Fabrican\n\nView-Cities -appName Contoso\nView-Cities -appName Fabrican\n\n')),Object(r.b)("h2",{id:"what-is-next"},"What is next?"),Object(r.b)("p",null,"I think Service Fabric has a lot of great and useful features that make it is a great candidate for a lot of scenarios. I will post more articles about Service Fabric as I expand my knowledge in this really cool technology. "))}p.isMDXComponent=!0}}]);