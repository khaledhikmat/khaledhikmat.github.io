(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{138:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var o=n(0),i=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),u=function(e){var t=i.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},d=function(e){var t=u(e.components);return i.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},p=i.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,a=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=u(n),p=o,m=d["".concat(a,".").concat(p)]||d[p]||b[p]||r;return n?i.a.createElement(m,c(c({ref:t},s),{},{components:n})):i.a.createElement(m,c({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,a[1]=c;for(var s=2;s<r;s++)a[s]=n[s];return i.a.createElement.apply(null,a)}return i.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},89:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return u}));var o=n(3),i=n(7),r=(n(0),n(138)),a={title:"Document Deletion in Azure DocumentDB",author:"Khaled Hikmat",author_title:"Software Engineer",author_url:"https://github.com/khaledhikmat",author_image_url:"https://avatars1.githubusercontent.com/u/3119726?s=400&u=090899e7b366dd702f9d0d5e483f20089010b25c&v=4",tags:["CosmosDB"]},c={permalink:"/blog/2017/03/30/deletes-in-docdb",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/blog/blog/2017-03-30-deletes-in-docdb.md",source:"@site/blog/2017-03-30-deletes-in-docdb.md",description:"I saw many posts about deleting documents in Azure DocumentDB...but none of them worked quite well for me. So I spent a few hours on this and finally got it to work. Below is my solution. The following posts helped me tremendously (thank you):",date:"2017-03-30T00:00:00.000Z",tags:[{label:"CosmosDB",permalink:"/blog/tags/cosmos-db"}],title:"Document Deletion in Azure DocumentDB",readingTime:4.56,truncated:!1,prevItem:{title:"Point to Site Connectivity in Azure",permalink:"/blog/2017/12/21/point-to-site-connectivity"},nextItem:{title:"Service Fabric Secure Cluster Deployment",permalink:"/blog/2017/02/21/service-fabric-secure-cluster"}},l=[{value:"Time",id:"time",children:[]},{value:"Partition Key",id:"partition-key",children:[]},{value:"Deletion",id:"deletion",children:[]}],s={toc:l};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"I saw many posts about deleting documents in Azure DocumentDB...but none of them worked quite well for me. So I spent a few hours on this and finally got it to work. Below is my solution. The following posts helped me tremendously (thank you):"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://talkingaboutdata.wordpress.com/2015/08/24/deleting-multiple-documents-from-azure-documentdb/"}),"https://talkingaboutdata.wordpress.com/2015/08/24/deleting-multiple-documents-from-azure-documentdb/")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://www.tutorialspoint.com/documentdb/documentdb_delete_document.htm"}),"https://www.tutorialspoint.com/documentdb/documentdb_delete_document.htm")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"http://stackoverflow.com/questions/29137708/how-to-delete-all-the-documents-in-documentdb-through-c-sharp-code"}),"http://stackoverflow.com/questions/29137708/how-to-delete-all-the-documents-in-documentdb-through-c-sharp-code")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://azure.microsoft.com/en-us/blog/working-with-dates-in-azure-documentdb-4/"}),"https://azure.microsoft.com/en-us/blog/working-with-dates-in-azure-documentdb-4/"))),Object(r.b)("p",null,"I basically wanted to delete aging documents (based on number of hours) from a collection. So my final routine looks like this. Below is some explanation:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'public async Task<int> DeleteAgingDocuments(Uri docDbUri, string docDbKey, string databaseName, string collectionName, int hours)\n{\n    using (var client = new DocumentClient(docDbUri, docDbKey))\n    {\n        try\n        {\n            var dbs = this._docDbClient.CreateDatabaseQuery().ToList();\n            if (dbs == null)\n                throw new Exception("No databases in the Docdb account!");\n            var db = dbs.Where(d => d.Id == databaseName).FirstOrDefault();\n            if (db == null)\n                throw new Exception($"No database [{databaseName}] in the Docdb account!");\n            var collections = this._docDbClient.CreateDocumentCollectionQuery(db.CollectionsLink).ToList();\n            if (collections == null)\n                throw new Exception($"No collections in the [{databaseName}] database in the Docdb account!");\n            var collection = this._docDbClient.CreateDocumentCollectionQuery(db.CollectionsLink).Where(c => c.Id == collectionName).ToList().FirstOrDefault();\n            if (collection == null)\n                throw new Exception($"No collection [{collectionName}] in the [{databaseName}] database in the Docdb account!");\n\n            int epocDateTime = DateTime.UtcNow.AddHours(-1 * hours).ToEpoch();\n            var dbQuery = "SELECT VALUE {\\"link\\": c._self, \\"source\\": c.source} FROM c WHERE c._ts < " + epocDateTime;\n            var docs = this._docDbClient.CreateDocumentQuery(collection.SelfLink, dbQuery, new FeedOptions { EnableCrossPartitionQuery = true }).ToList();\n            foreach (var doc in docs)\n            {\n                var link = (string)doc.link;\n                var source = (string)doc.source;\n                await this._docDbClient.DeleteDocumentAsync(link, new RequestOptions() { PartitionKey = new Microsoft.Azure.Documents.PartitionKey(source) });\n            }\n\n            return docs.Count;\n        }\n        catch (Exception ex)\n        {\n            // some debug \n        }\n    }\n}\n')),Object(r.b)("h3",{id:"time"},"Time"),Object(r.b)("p",null,"The first problem I encountered is how to select the aging documents! It turned out the best way to do this is to compare numbers as opposed to dates. This ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://azure.microsoft.com/en-us/blog/working-with-dates-in-azure-documentdb-4/"}),"post")," helped me understand what the problem is and how to go around doing it properly. I ended it up using the built-in time stamp value stored as meta data in every DocDB document i.e. ",Object(r.b)("inlineCode",{parentName:"p"},"_ts"),". This may or may not work for every case. In my case my collection document date i.e. ",Object(r.b)("inlineCode",{parentName:"p"},"eventDate")," is actually the real UTC time ....so it was no problem. If this is not the case, you many need to store your own time stamp (in addition to the date) so u can do the query to pull the aging documents based on time. "),Object(r.b)("p",null,"so this query does exactly that:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'int epocDateTime = DateTime.UtcNow.AddHours(-1 * hours).ToEpoch();\nvar dbQuery = $"SELECT * FROM c WHERE c._ts < {epocDateTime}";\n')),Object(r.b)("p",null,"Notice how I am using the Epoc time for my aging time stamp. The ",Object(r.b)("inlineCode",{parentName:"p"},"DateTime")," extension is written this way:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"public static int ToEpoch(this DateTime date)\n{\n    if (date == null) return int.MinValue;\n    DateTime epoch = new DateTime(1970, 1, 1);\n    TimeSpan epochTimeSpan = date - epoch;\n    return (int)epochTimeSpan.TotalSeconds;\n}\n")),Object(r.b)("h3",{id:"partition-key"},"Partition Key"),Object(r.b)("p",null,"My collection was partitioned over a value in the document i.e. ",Object(r.b)("inlineCode",{parentName:"p"},"source"),", but I wanted to trim all aging documents across all partitions...not against a single partition. So I used this query options to force the query to span multiple partitions:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"FeedOptions queryOptions = new FeedOptions { EnableCrossPartitionQuery = true };\n")),Object(r.b)("h3",{id:"deletion"},"Deletion"),Object(r.b)("p",null,"Finally, I wanted to loop through all aging documents and delete:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'int epocDateTime = DateTime.UtcNow.AddHours(-1 * hours).ToEpoch();\nvar dbQuery = "SELECT VALUE {\\"link\\": c._self, \\"source\\": c.source} FROM c WHERE c._ts < " + epocDateTime;\nvar docs = this._docDbClient.CreateDocumentQuery(collection.SelfLink, dbQuery, new FeedOptions { EnableCrossPartitionQuery = true }).ToList();\nforeach (var doc in docs)\n{\n    var link = (string)doc.link;\n    var source = (string)doc.source;\n    await this._docDbClient.DeleteDocumentAsync(link, new RequestOptions() { PartitionKey = new Microsoft.Azure.Documents.PartitionKey(source) });\n}\n')),Object(r.b)("h4",{id:"query"},"Query"),Object(r.b)("p",null,"Please note that the query that I used above uses a projection to get only the document link and the partition key....we really do not need the entire document:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'var dbQuery = "SELECT VALUE {\\"link\\": c._self, \\"source\\": c.source} FROM c WHERE c._ts < " + epocDateTime;\n')),Object(r.b)("p",null,"Also please note that I am using the ",Object(r.b)("inlineCode",{parentName:"p"},"VALUE")," modifier in the query so to force DocDB to return the value only. This will return a payload that looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'[\n  {\n    "link": "dbs/XEthAA==/colls/XEthAL4dCwA=/docs/XEthAL4dCwABAAAAAAAAAA==/",\n    "source": "Digital Controller"\n  },\n  {\n    "link": "dbs/XEthAA==/colls/XEthAL4dCwA=/docs/XEthAL4dCwACAAAAAAAAAA==/",\n    "source": "Profiler"\n  }\n]\n')),Object(r.b)("p",null,"If I don't include the ",Object(r.b)("inlineCode",{parentName:"p"},"VALUE")," modifier, I get this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'[\n  {\n    "$1": {\n      "link": "dbs/XEthAA==/colls/XEthAL4dCwA=/docs/XEthAL4dCwABAAAAAAAAAA==/",\n      "source": "Digital Controller"\n    }\n  },\n  {\n    "$1": {\n      "link": "dbs/XEthAA==/colls/XEthAL4dCwA=/docs/XEthAL4dCwACAAAAAAAAAA==/",\n      "source": "Profiler"\n    }\n  }\n]\n')),Object(r.b)("p",null,"I chose the first one :-)  "),Object(r.b)("h4",{id:"deletion-1"},"Deletion"),Object(r.b)("p",null,"Finally, we pull the documents and delete one at a time:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"var docs = this._docDbClient.CreateDocumentQuery(collection.SelfLink, dbQuery, new FeedOptions { EnableCrossPartitionQuery = true }).ToList();\nforeach (var doc in docs)\n{\n    var link = (string)doc.link;\n    var source = (string)doc.source;\n    await this._docDbClient.DeleteDocumentAsync(link, new RequestOptions() { PartitionKey = new Microsoft.Azure.Documents.PartitionKey(source) });\n}\n")),Object(r.b)("p",null,"Initially, I only got the document link from the query thinking that this was the only requirement. So I did something like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'var dbQuery = "SELECT VALUE c._self FROM c WHERE c._ts < " + epocDateTime;\nvar docs = this._docDbClient.CreateDocumentQuery(collection.SelfLink, dbQuery, new FeedOptions { EnableCrossPartitionQuery = true }).ToList();\nforeach (var doc in docs)\n{\n    await this._docDbClient.DeleteDocumentAsync(doc);\n}\n')),Object(r.b)("p",null,"This did not work! I needed to pass the partition key....this is why i changed the query to a projection so I can get the partition key. In my case the partition key is the ",Object(r.b)("inlineCode",{parentName:"p"},"source"),". There is a comment in this ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"http://stackoverflow.com/questions/29137708/how-to-delete-all-the-documents-in-documentdb-through-c-sharp-code"}),"post")," that gave me a clue that the request option must include the partition key."),Object(r.b)("p",null,"Thank you for reading! I hope this helps someone. "))}u.isMDXComponent=!0}}]);