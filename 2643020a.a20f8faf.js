(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{138:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return p}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),b=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},h=function(e){var t=b(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=b(n),u=r,p=h["".concat(o,".").concat(u)]||h[u]||m[u]||i;return n?a.a.createElement(p,c(c({ref:t},l),{},{components:n})):a.a.createElement(p,c({ref:t},l))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},80:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return b}));var r=n(3),a=n(7),i=(n(0),n(138)),o={title:"Service Fabric Notes",author:"Khaled Hikmat",author_title:"Software Engineer",author_url:"https://github.com/khaledhikmat",author_image_url:"https://avatars1.githubusercontent.com/u/3119726?s=400&u=090899e7b366dd702f9d0d5e483f20089010b25c&v=4",tags:["Service Fabric"]},c={permalink:"/blog/2017/01/10/service-fabric-notes",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/blog/blog/2017-01-10-service-fabric-notes.md",source:"@site/blog/2017-01-10-service-fabric-notes.md",description:"I am compiling notes when working with Service Fabric from the folks at Microsoft! In this post, I will enumerate a few things that I ran into which I think might be helpful to others who are learning the environment as well. This will not be a complete list ....so I will add to it as I go along.",date:"2017-01-10T00:00:00.000Z",tags:[{label:"Service Fabric",permalink:"/blog/tags/service-fabric"}],title:"Service Fabric Notes",readingTime:4.84,truncated:!1,prevItem:{title:"Web Tests Thoughts",permalink:"/blog/2017/02/15/web-test-thoughts"},nextItem:{title:"How to generate a static site using Wyam",permalink:"/blog/2016/12/23/how-to-generate-this-site"}},s=[{value:"Actor Turn-based Concurrency",id:"actor-turn-based-concurrency",children:[]},{value:"Actor Reminders",id:"actor-reminders",children:[]},{value:"Actor Interface",id:"actor-interface",children:[]}],l={toc:s};function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"I am compiling notes when working with ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://azure.microsoft.com/en-us/services/service-fabric/"}),"Service Fabric")," from the folks at Microsoft! In this post, I will enumerate a few things that I ran into which I think might be helpful to others who are learning the environment as well. This will not be a complete list ....so I will add to it as I go along."),Object(i.b)("h3",{id:"actor-turn-based-concurrency"},"Actor Turn-based Concurrency"),Object(i.b)("p",null,"Actors are single threaded! They only allow one thread to be acting on them at any given time. In fact, in the Service Fabric terminology, this is referred to as Turn-based treading. From my observation, it seems that this is how the platform and the actors "),Object(i.b)("p",null,"What happens to the clients who are calling the actors? If two clients are trying to access an actor at the same time, one blocks until the actor finishes the first client method. This is to ensure that an actor works on one thing at a time. "),Object(i.b)("p",null,"Let us say, we have an actor that has two methods like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-csharp"}),'public Task<string> GetThing1()\n{\n    // Simulate long work\n    Thread.Sleep(5000);\n    return Task.FromResult<string>("thing1");\n}\n\npublic Task<string> GetThing2()\n{\n    // Simulate long work\n    Thread.Sleep(10000);\n    return Task.FromResult<string>("thing2");\n}\n')),Object(i.b)("p",null,"If you call ",Object(i.b)("inlineCode",{parentName:"p"},"GetThing1")," from one client and immediately call ",Object(i.b)("inlineCode",{parentName:"p"},"GetThing2")," from another client (or Postman session), the second client will wait at least 15 seconds to get the string ",Object(i.b)("inlineCode",{parentName:"p"},"thing2")," response."),Object(i.b)("p",null,"Given this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"I think it is best to front-end actors with a service that can invoke methods on actors when it receives requests from a queue. This way the service is waiting on actors to complete processing while it is in its ",Object(i.b)("inlineCode",{parentName:"li"},"RunAsync")," method."),Object(i.b)("li",{parentName:"ul"},"It is important to realize that actors should really not be queried and that actors should employ several things:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Backup state to an external store such as DocumentDB or others. This way the external store can be queried instead."),Object(i.b)("li",{parentName:"ul"},"Aggregate result externally perhaps via Azure Function into some outside store so queries could run against this store"),Object(i.b)("li",{parentName:"ul"},"Aggregate result to an aggregator actor that can quickly respond to queries which will relieve the processing actors from worrying about query requests.")))),Object(i.b)("h3",{id:"actor-reminders"},"Actor Reminders"),Object(i.b)("p",null,Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-timers-reminders/"}),"Actor Reminders")," are really nice to have. In the sample app that I am working on, I use them to schedule processing after I return to the caller. Effectively they seem to give me the ability to run things asynchronously and return to the caller right away. Without this, the actor processing throughput may not be at best if the the processing takes a while to complete. "),Object(i.b)("p",null,"In addition to firing a future event, they do allow me to pack an item or object that can be retrieved when the reminder triggers. This makes a lot of scenarios possible because we are able to pack the item that we want the reminder to work on."),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Please note, however, that when a reminder is running in an actor, that actor cannot respond to other method invocation! This is because the platform makes sure that there is only a single threaded operating on an actor at any time.")," "),Object(i.b)("p",null,"The best way I found out to schedule reminders to fire immediately is something like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-csharp"}),'public async Task Process(SomeItem item)\n{\n    var error = "";\n\n    try\n    {\n        if (item == null)\n        {\n            ...removed for brevity\n            return;\n        }\n\n        await this.RegisterReminderAsync(\n            ReprocessReminder,\n            ObjectToByteArray(item),\n            TimeSpan.FromSeconds(0),            // If 0, remind immediately\n            TimeSpan.FromMilliseconds(-1));     // Disable periodic firing\n    }\n    catch (Exception ex)\n    {\n        error = ex.Message;\n    }\n    finally\n    {\n        ...removed for brevity\n    }\n}\n')),Object(i.b)("p",null,"When the reminder triggers, ",Object(i.b)("inlineCode",{parentName:"p"},"ReprocessReminder")," is called to process the item that was packed within the reminder: ",Object(i.b)("inlineCode",{parentName:"p"},"ObjectToByteArray(item)"),". Here are possible implementation of packing and unpacking the item:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-csharp"}),"private byte[] ObjectToByteArray(Object obj)\n{\n    if (obj == null)\n        return null;\n\n    BinaryFormatter bf = new BinaryFormatter();\n\n    try\n    {\n        using (var ms = new MemoryStream())\n        {\n            bf.Serialize(ms, obj);\n            return ms.ToArray();\n        }\n\n    }\n    catch (Exception ex)\n    {\n        return null;\n    }\n}\n\nprivate Object ByteArrayToObject(byte[] arrBytes)\n{\n    try\n    {\n        using (var memStream = new MemoryStream())\n        {\n            var binForm = new BinaryFormatter();\n            memStream.Write(arrBytes, 0, arrBytes.Length);\n            memStream.Seek(0, SeekOrigin.Begin);\n            var obj = binForm.Deserialize(memStream);\n            return obj;\n        }\n    }\n    catch (Exception ex)\n    {\n        return null;\n    }\n}\n")),Object(i.b)("h3",{id:"actor-interface"},"Actor Interface"),Object(i.b)("p",null,"From this ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-notes-on-actor-type-serialization/"}),"article"),": ",Object(i.b)("em",{parentName:"p"},"The arguments of all methods, result types of the tasks returned by each method in an actor interface, and objects stored in an actor's State Manager must be Data Contract serializable. This also applies to the arguments of the methods defined in actor event interfaces. (Actor event interface methods always return void.)")," "),Object(i.b)("p",null,"In my actor interface, I had many methods and everything was working great until I added these two methods:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-csharp"}),"Task<SomeView> GetView(int year, int month);\nTask<SomeView> GetView(int year);\n")),Object(i.b)("p",null,"If you to compile a Service Fabric solution that has an interface that looks like the above, you will be met with a very strange compilation error:"),Object(i.b)("p",null,Object(i.b)("img",Object(r.a)({parentName:"p"},{src:"http://i.imgur.com/cO972hG.png",alt:"Actor Compilation Error"}))),Object(i.b)("p",null,"What? What is that? Why? After hours, it turned out you can actually ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"http://stackoverflow.com/questions/35820191/how-to-ignore-a-servicetype-from-servicefabric-manifest-file-on-build-deploy"}),"turn off")," this error. From the above Stack Overflow post:"),Object(i.b)("p",null,"By changing the project file .csproj of the project containing the actors and setting property:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{}),"<UpdateServiceFabricManifestEnabled>false</UpdateServiceFabricManifestEnabled>\n")),Object(i.b)("p",null,"So this tool can be disabled!! But still why is this happening? It turned out that the actor interfaces may not have overridden methods!! So the tool was complaining about the interface containing just that i.e. overridden methods. If the above interface is changed to the below, everything will work well:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-csharp"}),"Task<SomeView> GetViewByYearNMonth(int year, int month);\nTask<SomeView> GetViewByYear(int year);\n")),Object(i.b)("p",null,"In addition, the actor event methods may not return anything but ",Object(i.b)("inlineCode",{parentName:"p"},"void"),". So if you have something like this, you will get the same ",Object(i.b)("inlineCode",{parentName:"p"},"FabActUtil.exe")," error:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-csharp"}),"public interface IMyActorEvents : IActorEvents\n{\n    Task MeasuresRecalculated(....);\n}\n")),Object(i.b)("p",null,"I am hoping to add to this post as I go along. Hopefully this has been helpful.\n"))}b.isMDXComponent=!0}}]);